# [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

## 一、问题

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续**

**子数组**

`[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

 

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

 

**提示：**

- `1 <= target <= 109`
- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 105`

 

**进阶：**

- 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。

## 二、思路

### 2.1 暴力解法

这道题目暴力解法当然是 两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是O(n^2)。

```java
public class Solution {
   public static int minSubArrayLen(int target, int[] nums) {
        int result = Integer.MAX_VALUE; // 初始化结果为最大值，用于记录最短子数组的长度
        int sum = 0; // 用于计算当前子数组的和
        int subLength = 0; // 当前子数组的长度

        for (int i = 0; i < nums.length; i++) {
            sum = 0; // 每次循环开始时，将 sum 重置为 0，计算新的子数组和

            for (int j = i; j < nums.length; j++) {
                sum += nums[j]; // 计算子数组的和

                if (sum >= target) {
                    subLength = j - i + 1; // 计算当前子数组的长度
                    result = result < subLength ? result : subLength; // 更新最短子数组的长度

                    break; // 找到一个和大于等于 target 的子数组，结束内层循环
                }
            }
        }

        return result == Integer.MAX_VALUE ? 0 : result; // 如果没有找到符合条件的子数组，返回 0，否则返回最短子数组的长度
    }
}
```

代码通过两层循环遍历数组，找到和大于等于给定目标值 `s` 的最短子数组的长度。外层循环从数组的第一个元素开始，内层循环从外层循环的当前位置开始，依次累加数组元素，直到和大于等于 `s` 或者遍历完数组。在内层循环中，如果找到符合条件的子数组，就更新最短子数组的长度。

这段代码的时间复杂度为 O(n^2)，其中 n 是数组的长度。可以通过优化算法来提高性能，例如使用双指针法或前缀和等技巧来减少不必要的循环次数。

- 时间复杂度：O(n^2)
- 空间复杂度：O(1)

后面力扣更新了数据，暴力解法已经超时了。



### 2.2 双指针法

通过使用双指针法进行优化，以减少不必要的循环次数。双指针法中，使用两个指针 `left` 和 `right` 来表示子数组的起始和结束位置。

```java
public class Solution {
    public static int minSubArrayLen(int target, int[] nums) {
        int result = Integer.MAX_VALUE; // 初始化结果为最大值，用于记录最短子数组的长度
        int sum = 0; // 用于计算当前子数组的和
        int left = 0; // 左指针
        int subLength = 0; // 当前子数组的长度

        for (int right = 0; right < nums.length; right++) { // 右指针从数组的第一个元素开始遍历
            sum += nums[right]; // 累加右指针所指向的元素

            while (sum >= target) { // 当子数组的和大于等于目标值时，移动左指针并更新最短子数组的长度
                subLength = right - left + 1; // 计算当前子数组的长度
                result = Math.min(result, subLength); // 更新最短子数组的长度
                sum -= nums[left]; // 移动左指针，更新子数组的和
                left++; // 左指针右移
            }
        }

        return result == Integer.MAX_VALUE ? 0 : result; // 如果没有找到符合条件的子数组，返回 0，否则返回最短子数组的长度
    }
}
```

代码通过使用双指针法，将时间复杂度降低到 O(n)，其中 n 是数组的长度。通过移动左指针和右指针，动态地计算子数组的和，同时更新最短子数组的长度。这样可以避免不必要的循环，并提高算法的效率。

### 2.3 前缀和

使用前缀和（Prefix Sum）可以对该问题进行优化，从而减少时间复杂度。

前缀和是指将数组中每个位置的元素与其前面所有元素的和预先计算出来，并存储在一个辅助数组中。通过使用前缀和，我们可以在 O(1) 的时间复杂度内计算任意两个位置之间的子数组和。

以下是使用前缀和优化的代码：

```java
public class Solution {
    public static int minSubArrayLen(int target, int[] nums) {
        int result = Integer.MAX_VALUE; // 初始化结果为最大值，用于记录最短子数组的长度
        int[] prefixSum = new int[nums.length + 1]; // 前缀和数组
        int subLength = 0; // 当前子数组的长度

        // 计算前缀和数组
        for (int i = 1; i <= nums.length; i++) {
            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];
        }

        for (int i = 0; i < nums.length; i++) {
            int targetSum = prefixSum[i] + target; // 计算目标和

            // 使用二分查找在前缀和数组中找到第一个大于等于目标和的位置
            int left = i + 1;
            int right = nums.length;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (prefixSum[mid] >= targetSum) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }

            // 更新最短子数组的长度
            if (left <= nums.length) {
                subLength = left - i;
                result = Math.min(result, subLength);
            }
        }

        return result == Integer.MAX_VALUE ? 0 : result; // 如果没有找到符合条件的子数组，返回 0，否则返回最短子数组的长度
    }
}
```

过使用前缀和和二分查找，在每个位置上计算目标和，并在前缀和数组中查找第一个大于等于目标和的位置。通过更新最短子数组的长度，可以在更短的时间内找到结果，从而优化了算法的性能。

### 2.4 滑动窗口

接下来就开始介绍数组操作中另一个重要的方法：**滑动窗口**。

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。

那么滑动窗口如何用一个for循环来完成这个操作呢。

首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。

如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？

此时难免再次陷入 暴力解法的怪圈。

所以 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。

那么问题来了， 滑动窗口的起始位置如何移动呢？

这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：

![动画](4.209%20%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.assets/%E5%8A%A8%E7%94%BB.gif)

最后找到 4，3 是最短距离。

其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。

在本题中实现滑动窗口，主要确定如下三点：

- 窗口内是什么？
- 如何移动窗口的起始位置？
- 如何移动窗口的结束位置？

窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。

窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。

窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。

解题的关键在于 窗口的起始位置如何移动，如图所示：

![leetcode_209](4.209%20%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.assets/20210312160441942.png)

可以发现**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。**

C++代码如下：

```cpp

```

- 时间复杂度：O(n)
- 空间复杂度：O(1)

**一些录友会疑惑为什么时间复杂度是O(n)**。

不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。
