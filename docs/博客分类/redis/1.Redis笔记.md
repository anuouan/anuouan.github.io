# Redis学习笔记

## 一、Redis介绍

redis 是完全开源免费的，遵守BSD协议，是⼀个⾼性能的key-value数据库。

<img src="1.Redis%E7%AC%94%E8%AE%B0.assets/image-20240310154413832.png" alt="image-20240310154413832" style="zoom:50%;" />

这⾥提到了key-value数据库，这是什么那，其实我们在之前就学习过数据库分为两种，⼀种是关系型数据库，⼀种为⾮关系型型数据库，其实Redis就是⼀个⾮关系型数据库，并且可基于内存亦可持久化的⽇志型、Key-Value数据库，并提供多种语⾔的API。

其实这种数据库有⼀个名词叫做NoSql。

## 二、NoSQL

NoSQL指的是⾮关系型数据库。NoSQL也称之为Not Only SQL（不仅仅只是SQL）的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。

### 2.1 为什么需要使⽤NoSQL

传统关系型数据库在应付**超⼤规模**和**⾼并发**⽹站时就会出现各种问题，甚⾄是⼒不从⼼了，⽐如：

1.  对数据库⾼并发读写需求：

    关系型数据库应对上万次的SQL查询，勉勉强强顶得住，但是⼀旦⾯对上万次的SQL写操作，硬盘IO就已经⽆法承受了。

2.  海量数据⾼效储存及访问

    ⽐较⼤型的⽹站，每天⽤户产⽣的数据是⾮常庞⼤的，因为现在的应⽤系统⼀般都需要有⽇志的功能来记录⽤户的⾏为以及系统信息等，所以有⼀些⼤型⽹站⼀个⽉就达到了2.5亿的⽤户动态，如果我们想在⼀张如此庞⼤的数据表中查询某⼀条数据信息，效率之差是我们⽆法忍受的。

3.  数据库的⾼拓展和⾼可⽤性需求

    基于Web框架当中，数据库是最难进⾏横向拓展的，它不会像WebServer或者 AppServer那样进⾏简单的硬件和服务节点的拓展就能提⾼性能和负载，对于很多24⼩时不间断的服务来说，对数据库进⾏升级和拓展是⼀件⾮常痛苦的事情。

    针对以上提到的问题，促使产⽣了NoSQL数据库来解决问题，因为它就是⽤于解决**超⼤规模数据的存储和多重数据种类**所带来的的问题，这些类型的数据存储不需要固定的模式，⽆需多余操作就可以横向扩展。

总结：

今天我们可以通过第三⽅平台（如：Google,Facebook等）可以很容易的访问和抓取数据。⽤户的个⼈信息，社交⽹络，地理位置，⽤户⽣成的数据和⽤户操作⽇志已经成倍的增加。我们如果要对这些⽤户数据进⾏挖掘，那SQL数据库已经不适合这些应⽤了, NoSQL 数据库的发展却能很好的处理这些⼤的数据。

### 2.2 NoSQL的优点/缺点

优点:

-   ⾼可扩展性
-   分布式计算
-   低成本
-   架构的灵活性，半结构化数据
-   没有复杂的关系


缺点:

-   没有标准化
-   有限的查询功能（到⽬前为⽌）
-   最终⼀致性

### 2.3 NoSQL类别

NoSQL分为以下的类别

| **类型**       | **部分代表**                                        | **特点**                                                                                                                             |
|----------------|-----------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------|
| 列存储         | Hbase Cassandra Hypertable                          | 顾名思义，是按列存储数据的。最⼤的特点是⽅便存储结构化和半结构化数据，⽅便做数据压缩，对针对某⼀列或者某⼏列的查询有⾮常⼤的IO优势。 |
| ⽂档存储       | MongoDB CouchDB                                     | ⽂档存储⼀般⽤类似json的格式存储，存储的内容是⽂档型的。这样也就有机会对某些字段建⽴索引，实现关系数据库的某些功能。                 |
| key- value存储 | Tokyo Cabinet / Tyrant Berkeley DB MemcacheDB Redis | 可以通过key快速查询到其value。⼀般来说，存储不管 value的格式，照单全收。（Redis包含了其他功能）                                      |
| 图存储         | Neo4J FlockDB                                       | 图形关系的最佳存储。使⽤传统关系数据库来解决的话性能低下，⽽且设计使⽤不⽅便。                                                       |
| 对象存储       | db4o Versant                                        | 通过类似⾯向对象语⾔的语法操作数据库，通过对象的⽅式存取数据。                                                                       |
| xml数据库      | Berkeley DB XML BaseX                               | ⾼效的存储XML数据，并⽀持XML的内部查询语法，⽐如XQuery,Xpath。                                                                       |

## 三、Redis⼊⻔

Redis 是由C语⾔编写的⼀个远程内存数据库，它不仅性能强劲，⽽且还具有复制特性以及为解决问题⽽⽣的独⼀⽆⼆的数据模型。

Redis是完全开源免费的，遵守BSD协议，是⼀个⾼性能的key-value数据库，并提供多种语⾔的API。

Redis 与其他 key - value 缓存产品有以下三个特点：

- Redis⽀持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进⾏使⽤。

- Redis不仅仅⽀持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。

- Redis⽀持数据的备份，即master-slave模式的数据备份。

### 3.1 为什么要使⽤Redis

以往，我们系统的只需要从数据库读取出数据，展示在⻚⾯就可以了。后来随着时代的发展系统越来越复杂了，传统的模式越来越难以⽀撑，缓存技术也在系统中占据越来越重要的⻆⾊，⽽Redis就是⽬前市场使⽤量最多的缓存技术。

### 3.2 Redis特点

- 性能极⾼ – Redis能读的速度是110000次/s,写的速度是81000次/s 。

- 丰富的数据类型 – Redis⽀持⼆进制的 Strings, Lists, Hashes, Sets 及 Ordered Sets数据类型操作。

- 原⼦ – Redis的所有操作都是原⼦性的，同时Redis还⽀持对⼏个操作全部的原⼦性执⾏。

- 丰富的特性 – Redis还⽀持 publish/subscribe, 通知, key 过期等等特性。

- ⾼速读写-Redis使⽤⾃⼰实现的分离器，代码量短，没有使⽤Lock(锁MySQL)，因此效率⾼

- 持久化-Redis直接将数据存储到内存中，要将数据保存到磁盘上，Redis可以通过两种⽅式实现持久化。

  - 定时快照(snapshot)：每隔⼀段时间将整个数据库内容写⼊到磁盘上，因为每次都是全部数据，**代价⽐较⾼**。

  - 基于语句追加(aof)：只追踪变化的数据，但是追加的log可能很⼤，同时所有的操作均重新执⾏⼀次，**回复速度慢**。

#### 3.2.1 Redis优势

1.  ⾼性能：

    假设下如果所有的数据都从数据库中读取，特别是是⼀些复杂的数据，每次都查询 mysql性能必定⾮常差。所以对于**⼀些复杂操作耗时查出来的结果且确定后⾯不怎么变化的数据放到缓存，能⼤幅提⾼系统响应。**

2.  ⾼并发：

    mysql单机⼀般只能⽀撑到2000Qps，⽽Redis由于是K/V式的操作，单机可以⽀撑并发量可达到⼏万到⼗⼏万。


#### 3.2.2 Redis缺点

1. 数据库容量受到物理内存的限制，不能⽤作海量数据的⾼性能读写，因此

   Redis适合的场景主要局限在较⼩数据量的⾼性能操作和运算上。

2. Redis 不具备⾃动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者⼿动切换前端的IP才能恢复。
3. 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引⼊数据不⼀致的问题，降低了系统的可⽤性。

4. Redis 较难⽀持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这⼀问题，运维⼈员在系统上线时必须确保有⾜够的空间，这对资源造成了很⼤的浪费。

### 3.3 Redis应⽤场景

根据业内项⽬的实战经验及企业开发中总结的应⽤场景：

- 缓存

- 秒杀

- 计数器排⾏榜

- 热点数据（经常查询，但是不经常修改或者删除的数据）分布式锁

- 分布式ID消息系统

- 等等⼤部分与系统性能密切相关的场景

## 四、Redis安装

⾸先各位要知道Redis本身就没有针对Window系统进⾏开发，所以⼤家如果能下载到的win版本的Redis其实都是微软⾃⾏研发的，我们正常使⽤也都是基于Linux，所以整体安装我们都是针对Linux来进⾏的。所以⾸先需要准备⼀台虚拟机系统采

⽤：**CentOS7**即可

官⽹⽹址： **https://redis.io/**

官⽹下载地址： **https://redis.io/download/**

我们采⽤最新版本7.0

<img src="1.Redis%E7%AC%94%E8%AE%B0.assets/image-20240310154441029.png" alt="image-20240310154441029" style="zoom:50%;" />

在这可以直接点击下载**Download 7.0.11**，下载之后启动虚拟机，通过远程⼯具连接然后将下载好的Redis上传到虚拟机中进⾏安装即可，这是整体⽅式，但是要注意⾸先我们需要先安装GCC依赖

### 4.1 GCC依赖

Redis是基于C语⾔编写的，需要此依赖对Redis源码进⾏编译

```bash
yum install -y gcc tcl
```

### 4.2 具体步骤

1、上传redis-7.0.11.tar.gz到虚拟机opt⽬录中

![image-20240310154622356](1.Redis%E7%AC%94%E8%AE%B0.assets/image-20240310154622356.png)

2、解压此⽂件

```bash
tar -xzvf redis-7.0.11.tar.gz
```

**3、进⼊到redis⽬录中进⾏安装**

![image-20240310154717868](1.Redis%E7%AC%94%E8%AE%B0.assets/image-20240310154717868.png)

```bash
make && make install # 编译且安装
```

**默认安装路径存在于：/usr/local/bin**

## 五、Redis启动

Redis启动⽅式有多种：

- 默认启动

- 指定配置启动
- 开机⾃启

⾸先我们先进⼊到默认的Redis安装⽬录： /usr/local/bin

![image-20240310154921993](1.Redis%E7%AC%94%E8%AE%B0.assets/image-20240310154921993.png)

此⽬录包含所有redis相关默认的配置，我们可以运⾏以下命令

```bash
redis-cil #redis提供的命令⾏客户端
redis-server #redis服务端启动脚本
redis-sentinel #redis哨兵启动脚本
```

### 5.1 默认启动

我们⾸先启动redis服务端，当然启动redis可以在任何⽬录位置都⾏，因为已经加⼊环境变量了，不⼀定⾮要进⼊安装⽬录

```bash
redis-server
```

![image-20240310155041953](1.Redis%E7%AC%94%E8%AE%B0.assets/image-20240310155041953.png)

当然此时这种启动⽅式为：前台启动，也就是说，我们如果此时想去连接Redis服务端，需要在开启⼀个窗⼝，此窗⼝状态⼀致保持，如果此时停⽌，Redis也就停⽌ 了，所以这种⽅式并不是很友好

### 5.2 指定配置启动

如果想要进⾏后台启动，我们就需要修改Redis配置，我们需要修改的⽂件为：`redis.conf`

在咱们的Redis解压⽬录中

![image-20240310155140259](1.Redis%E7%AC%94%E8%AE%B0.assets/image-20240310155140259.png)

注意：如果要修改配置我们⼀般情况下需要先备份

```bash
cp redis.conf redis.conf.bck
```

执⾏⼀下命令修改具体配置

```bash
vim redis.conf
```

![image-20240310155301942](1.Redis%E7%AC%94%E8%AE%B0.assets/image-20240310155301942.png)

#### 5.2.1 配置具体修改

```redis.conf
# 监听地址，默认为127.0.0.1，所以只能本地访问，我们可以修改为0.0.0.0，表示任
意IP访问，但是注意，此设置仅⽤于测试
bind 0.0.0.0
# 将守护进程，从默认的关闭改为开启，即为后台运⾏
daemonize yes
# 设置访问密码，任意访问，但是需要密码
requirepass 753159
# -----------------常⻅配置（按情况⾃⾏调整，建议增加⽇志）--------------
-----
# 监听的端⼝
port 6379
# ⼯作空间，默认是当前⽬录，运⾏redis-server时的命令，⽇志、持久化等⽂件会保
存在这个⽬录
dir .
# 数据库数量，设置为1，代表只使⽤1个库，默认有16个库，编号0~15（MySQL可以⾃
⼰创建Redis不需要但是可以指定数量）
databases 16
# 设置redis能够使⽤的最⼤内存
maxmemory 512mb
# ⽇志⽂件，默认不记录⽇志，可以指定⽇志⽂件名来开启记录⽇志
logfile "redis.log"
```

#### 5.2.2 启动测试

此时的启动我们需要带着配置⽂件进⾏执⾏，我们此时正好在redis配置⽂件所在的路径中，所以可以不写全路径，直接启动带上配置⽂件即可

```bash
redis-server redis.conf
```

![image-20240310155459666](1.Redis%E7%AC%94%E8%AE%B0.assets/image-20240310155459666.png)

此时变成后台启动，所以没有⽇志，我们可以通过以下命令查看启动情况，当然停⽌的话直接杀死进程即可

```bash
ps -ef | grep redis # 查看redis运⾏的进程号
kill -9 115931# 杀死进程
```

![image-20240310155536664](1.Redis%E7%AC%94%E8%AE%B0.assets/image-20240310155536664.png)

### 5.3 开启⾃启动

Redis最简单的启动⽅式就是开机⾃启动，就好像MySQl那样，通过系统服务来进⾏⾃启动，Redis也可以做到。

1、新建系统服务

```bash
vi /etc/systemd/system/redis.service
```

具体内容

```bash
[Unit]
Description=redis-server
After=network.target
[Service]
Type=forking
ExecStart=/usr/local/bin/redis-server /root/opt/redis-
7.0.11/redis.conf #配置执⾏脚本
PrivateTmp=true
[Install]
WantedBy=multi-user.target
```

2、重载系统服务

```bash
systemctl daemon-reload
```

3、执⾏此命令让redis服务开启开机⾃启动

```bash
systemctl enable redis
```

4、通过以下命令操作redis系统服务

```bash
# 启动
systemctl start redis
# 停⽌
systemctl stop redis
# 重启
systemctl restart redis
# 查看状态
systemctl status redis
```

### 5.4 Redis客户端访问

和MySQL⼀样，Redis⾃带⼀个命令⾏客户端：redis-cli，具体使⽤⽅式如下

```bash
redis-cli [options]
```

options代表具体的⼀些选项，⽐如常⻅的如下：

- \-h 127.0.0.1：指定要连接的redis节点ip地址，默认是本机

- \-p 6379：指定要连接的redis节点的端⼝

- \-a 753159：指定redis访问密码

![image-20240310160856973](1.Redis%E7%AC%94%E8%AE%B0.assets/image-20240310160856973.png)

1、ping命令

Ping 命令使⽤客户端向 Redis 服务器发送⼀个 PING ，如果服务器运作正常的话，会返回⼀个 PONG 。

通常⽤于测试与服务器的连接是否仍然⽣效，或者⽤于测量延迟值。

我们可以通过这样的命令来进⾏测试：

![image-20240310161004961](1.Redis%E7%AC%94%E8%AE%B0.assets/image-20240310161004961.png)

**注意：Redis默认16个数据库，默认使⽤第0个**

可以通过Select进⾏切换，当然我们还可以查看当前库⼤⼩

```bash
select 0 # 切换数据库
dbsize # 查看数据库⼤⼩
```

当然因为它是key:value结构的，我们还可以直接通过set与get来添加数据，当然还有⼀些基础命令如下：

```bash
set name qf # 存⼊数据
get qf # 取出数据
keys * # 查看所有的key
flushall # 清除全部库数据
flushdb #清空当前库数据
```

![image-20240310161114939](1.Redis%E7%AC%94%E8%AE%B0.assets/image-20240310161114939.png)

### 5.5 Redis认知补充

#### 5.5.1 Redis快的真正原因

1.  **内存存储：** Redis将所有数据保存在内存中，内存读写速度⾮常快，远快于硬盘。这也是Redis最主要的性能优势。
2.  **数据结构简单：** Redis⽀持的数据结构⽐较简单（例如字符串，哈希，列表，集合和有序集合），这也在⼀定程度上提⾼了其效率。
3.  **⾮阻塞IO：** Redis使⽤单线程和⾮阻塞I/O多路复⽤库处理并发连接。在处理⼤量并发连接时，这种模型⽐多线程和阻塞I/O的模型要⾼效。
4.  **持久化策略：** Redis提供了多种灵活的数据持久化⽅式，包括RDB快照和AOF⽇志。⽤户可以根据需求选择最合适的持久化策略，以平衡性能和数据安全之间的关系。
5.  **优化的数据结构：** Redis为了⾼效地实现其命令，使⽤了许多优化的数据结构和算法，例如快速列表，跳跃列表和压缩列表
6.  总结：因此，Redis可以处理⼤量的读写操作，特别是在需要⾼速缓存，会话缓存，队列和发布/订阅等⾼性能场景中，Redis的性能表现⾮常出⾊。

#### 5.5.2 Redis是单线程的吗？

Redis在处理命令请求时是单线程的，也就是说在任意时刻，Redis只会使⽤⼀个CPU核⼼。Redis的作者Antirez（Salvatore Sanfilippo）设计Redis时，就选择了这种单线程模型，因为在很多场景下，单线程能够更好地避免竞态条件和复杂的同步问题，简化了系统的设计和运⾏机制。

然⽽，这并不意味着Redis的所有操作都是单线程的。例如，Redis的某些后台操 作，如持久化、数据清理和复制等，是由单独的线程完成的。另外，从Redis 4.0开始，某些耗时的操作，如删除⼤key和LRU过期等，也可以由后台线程异步处理。

所以，在理解Redis是单线程的时候，需要理解这是指Redis**主线程**处理⽹络请求和执⾏命令是单线程的。这种设计充分利⽤了CPU和内存的⾼速性能，避免了**多线程之间的上下⽂切换和资源**竞争，保证了极⾼的执⾏效率。

## 六、Redis数据类型

其实最经典的就是5⼤数据类型，具体如下：

当然因为Redis是⼀个key-value的数据库，key⼀般是String类型。

- String 
- List 
- Set 
- Hash

- SortedSet（Zset）

当然除了这些以外还有⼀些特殊的类型，总体凑起来⽬前应该是有10个数据类型，所以我们先从主要的数据类型开始

这⾥说⼀下，如果想详细学习每个类型具体的⼀些命令和使⽤，我们其实可以参照官⽹： **https://redis.io/docs/data-types/**

![image-20240310162136046](1.Redis%E7%AC%94%E8%AE%B0.assets/image-20240310162136046.png)

#### 6.1 Redis Key的基本命令

`keys *` 查看所有的key

`Exists key [key...]` 判断当前key是否存在。

`EXPIRE key seconds` 设置key 的过期时间，超过时间后，将会⾃动删除该key，单位是秒。(热点数据)

`TTL key` 返回key剩余的过期时间。 这种反射能⼒允许Redis客户端检查指定key在数据集⾥⾯剩余的有效期。

- 如果key不存在或者已过期，返回 -2
- 如果key存在并且没有设置过期时间（永久有效），返回 -1 。

`Move key db` 将当前数据库的 key 移动到给定的数据库 db 当中。如果当前数据库(源数据库)和给定数据库(⽬标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。
`TYPE key` 返回 key 所存储的 value 的数据结构类型。
`DEL key [key...]` 删除指定的⼀批keys，如果删除中的某些key不存在，则直接忽略
`flushall` 清除全部库数据
`flushdb` 清空当前库数据

```bash
127.0.0.1:6379[1]> set name Mask
OK
127.0.0.1:6379[1]> set age 18
OK
127.0.0.1:6379[1]> exists age
(integer) 1
127.0.0.1:6379[1]> exists aa
(integer) 0
127.0.0.1:6379[1]> set hot aaa
OK
127.0.0.1:6379[1]> expire hot 10
(integer) 1
127.0.0.1:6379[1]> ttl hot
(integer) 7
127.0.0.1:6379[1]> ttl hot
(integer) 4
127.0.0.1:6379[1]> ttl hot
(integer) 2
127.0.0.1:6379[1]> ttl hot
(integer) -2
127.0.0.1:6379[1]> keys *
1) "name"
2) "age"
127.0.0.1:6379[1]> move age 0
(integer) 1
127.0.0.1:6379[1]> select 0
OK
127.0.0.1:6379> keys *
1) "age"
127.0.0.1:6379> type age
string
127.0.0.1:6379> del age
(integer) 1
127.0.0.1:6379>
```

#### 6.2 Redis数据类型-String

String类型可以是说Redis最基本也是最常⽤的数据类型了，⼀个key对应⼀个 value。

String类型基本上可以包含任何数据，⽐如图⽚或者序列化的对象等。

⼀个Redis中的字符串value最多可以是512M 

String的常⻅命令：

`SET`：添加或者修改已经存在的⼀个String类型的键值对（如果key不存在则是新增，如果存在则是修改）
`GET`：根据key获取String类型的value
`GETSET`：先获取在设置，如果get时值不存在返回空，然后在进⾏设置，如果get时值存在，返回对应的值，在进⾏修改
`APPEND`：Append 命令⽤于为指定的 key 追加值，如果 key 已经存在并且是⼀个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。如果 key 不存在，
`APPEND` 就简单地将给定 key 设为 value ，就像执⾏ SET key value ⼀样。
`MSET`：批量添加多个String类型的键值对
`MGET`：根据多个key获取多个String类型的value
`MSETNX`： 命令⽤于所有给定 key 都不存在时，同时设置⼀个或多个 key-value对。（原⼦性操作）
`INCR`：命令将 key 中储存的数字值增⼀。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执⾏ INCR 操作。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回⼀个错误。本操作的值限制在 64 位(bit)有符号数字表示之内。
`INCRBY`:让⼀个整型的值⾃增并指定步⻓（例如： num 5 让num值⾃增5，其余与上⽅⼀致）
`DECR`：命令将 key 中储存的数字值减⼀（与INCR命令相反，其余⼀致）。
`DECRBY`： 命令将 key 所储存的值减去指定的减量值（与INCRBY相反，其余⼀致）。
`SETNX`：添加⼀个String类型的键值对，前提是这个key不存在，否则不执⾏（与MSETNX区别在于，此命令只能设置⼀组key:value）
`SETEX`：命令为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值

**注意**：set与setnx区别

在Redis中， SET 和 SETNX 命令⽤于设置字符串类型的键值，但它们在处理键已经存在的情况下的⾏为是不同的。当然 MSET 与 MSETNX 与之同理，只是添加MSET与MSETNX可以批量添加数据

- SET 命令：如果键已经存在， SET 会直接覆盖旧的值，⽆论键是否存在，都将设置新值。 例如： SET mykey "Hello"
- SETNX 命令： SETNX 表示"SET if Not eXists"，也就是只有在键不存在的情况下，才会设置新的值。如果键已经存在， SETNX 将不做任何操作。 例如： SETNX mykey "Hello"

SETNX 命令常常被⽤于实现锁和其他需要保证原⼦性的操作。例如，你可以使⽤ SETNX 来实现⼀个分布式锁，只有第⼀个请求的客户端可以获得锁（设置成功），后来的客户端因为键已经存在，所以设置失败，从⽽实现锁的功能。

总的来说， SET 和 SETNX 的主要区别在于它们如何处理键已经存在的情况。

```bash
# Set与Get
127.0.0.1:6379[1]> set name mask
OK
127.0.0.1:6379[1]> get name
"mask"
127.0.0.1:6379[1]> set name zhangsan # key存在，修改对应值
OK
127.0.0.1:6379[1]> get name
"zhangsan"
127.0.0.1:6379[1]>
# GETSET
127.0.0.1:6379[1]> getset age 18 # key不存在，返回nil 同时设置值
(nil)
127.0.0.1:6379[1]> get age
"18"
127.0.0.1:6379[1]> getset age 28 # key存在，返回具体值，同时修改值为28
"18"
127.0.0.1:6379[1]> get age
"28"
127.0.0.1:6379[1]>
# APPEND
127.0.0.1:6379[1]> append name version1 # key存在：在原有字符串上进⾏
追加
(integer) 16
127.0.0.1:6379[1]> get name
"zhangsanversion1"
127.0.0.1:6379[1]> append db redis # key不存在：相当于执⾏ SET key
value ⼀样。
(integer) 5
127.0.0.1:6379[1]> get db
"redis"
127.0.0.1:6379[1]>
# MSET与MGET
127.0.0.1:6379[1]> mset k1 a1 k2 a2 k3 a3
OK
127.0.0.1:6379[1]> mget k1 k2 k3
1) "a1"
2) "a2"
3) "a3"
127.0.0.1:6379[1]>
# MSET与MGET实战对象设计
# 这⾥的key是Redis⽀持的⼀种巧妙的设计：user:{id}:{filed}
127.0.0.1:6379[1]> mset user:1:name lisi user:1:age 18
OK
127.0.0.1:6379[1]> mget user:1:name user:1:age
1) "lisi"
2) "18"
127.0.0.1:6379[1]>
# MSETNX
127.0.0.1:6379[1]> msetnx k4 a5 k5 a5
(integer) 1
127.0.0.1:6379[1]> mget k4 k5
1) "a5"
2) "a5"
127.0.0.1:6379[1]> msetnx k4 a4 k6 a6 # 原⼦性操作，要么都成功，要么都
失败
(integer) 0
127.0.0.1:6379[1]> keys *
1) "db"
2) "k2"
3) "k4"
4) "k3"
5) "user:1:age"
6) "k5"
7) "name"
8) "user:1:name"
9) "k1"
10) "age"
127.0.0.1:6379[1]>
# INCR与INCRBY & DECR与DECRBY
127.0.0.1:6379[1]> set num 1
OK
127.0.0.1:6379[1]> incr num
(integer) 2
127.0.0.1:6379[1]> incr num
(integer) 3
127.0.0.1:6379[1]> decr num
(integer) 2
127.0.0.1:6379[1]> decr num
(integer) 1
127.0.0.1:6379[1]> incrby num 3
(integer) 4
127.0.0.1:6379[1]> incrby num 3
(integer) 7
# DECR与DECRBY与其道理⼀致
# SETNX
127.0.0.1:6379[1]> keys *
1) "db"
2) "k2"
3) "k4"
4) "k3"
5) "user:1:age"
6) "num"
7) "k5"
8) "name"
9) "user:1:name"
10) "k1"
11) "age"
127.0.0.1:6379[1]> setnx k6 qf
(integer) 1
127.0.0.1:6379[1]> setnx name wangwu # key存在⽆法执⾏
(integer) 0
127.0.0.1:6379[1]> get k6
"qf"
127.0.0.1:6379[1]> get name
"zhangsanversion1"
# SETEX
127.0.0.1:6379[1]> set k6 a6
OK
127.0.0.1:6379[1]> get k6
"a6"
127.0.0.1:6379[1]> setex k6 20 redis #设置过期时间，并且替换旧值
OK
127.0.0.1:6379[1]> ttl k6
(integer) 17
127.0.0.1:6379[1]> ttl k6
(integer) 15
127.0.0.1:6379[1]> get k6
"redis"
127.0.0.1:6379[1]> get k6 # 超时，清除
(nil)
127.0.0.1:6379[1]>
```

除了以上这些 String还有⼀些类似于Java字符串操作的命令，⽐如截取字符串等，具体可以参照官⽹。
其实String的使⽤场景很多，⽐如：

- 计数器
- 统计多单位数量
- 粉丝数
- 对象缓存储存

#### 6.3 Redis数据类型-List

![](1.Redis%E7%AC%94%E8%AE%B0.assets/36e3edccba3237c21ffc406a55964721.png)List类型是⼀种有序集合，也是Redis的基础数据结构之⼀。List类型内部实现为

⼀个双向链表，即每个节点都有两个指针，⼀个指向前⼀个节点，⼀个指向后

⼀个节点。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/36e3edccba3237c21ffc406a55964721.png)List功能⾮常强⼤，我们既可以把它当成栈（先进后出）、队列（先进先出），阻塞队列（超时时间）并且可以存放重复的值。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/36e3edccba3237c21ffc406a55964721.png)List甚⾄可以使⽤负数下标，以 -1 表示列表的最后⼀个元素， -2 表示列表的倒数第⼆个元素，以此类推。

###### 常⽤命令

![](1.Redis%E7%AC%94%E8%AE%B0.assets/36e3edccba3237c21ffc406a55964721.png)![](media/36e3edccba3237c21ffc406a55964721.png)LPUSH key value1 value2 将⼀个或多个值插⼊到列表头部（左侧） LRANGE key start stop 获取列表指定范围内的元素，根据下标

![](1.Redis%E7%AC%94%E8%AE%B0.assets/61b7a6d761fb9a5b576547d760da756a.png)![](media/61b7a6d761fb9a5b576547d760da756a.png)RPUSH key value1 value2 在列表中（右侧）添加⼀个或多个值 LPOP key 移除并获取列表的第⼀个元素

![](media/61b7a6d761fb9a5b576547d760da756a.png)![](media/61b7a6d761fb9a5b576547d760da756a.png)![](media/61b7a6d761fb9a5b576547d760da756a.png)RPOP key 移除并获取列表最后⼀个元素 LINDEX key index 通过索引获取列表中的元素 LLEN key 获取列表⻓度

![](1.Redis%E7%AC%94%E8%AE%B0.assets/8c46d616bde7f5959e9f9d6fd1ca4f86.png)LREM key count value 移除列表元素（可以移除多个重复的值）

![](media/61b7a6d761fb9a5b576547d760da756a.png)LTRIM key start stop 对⼀个列表进⾏修剪(trim)，就是说，通过下标让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。

![](media/61b7a6d761fb9a5b576547d760da756a.png)RPOPLPUSH source destination 移除列表的最后⼀个元素，并将该元素添加到另

⼀个列表并返回

![](1.Redis%E7%AC%94%E8%AE%B0.assets/8c46d616bde7f5959e9f9d6fd1ca4f86.png)EXISTS 也可以判断列表中是否有值（exists list）

![](media/61b7a6d761fb9a5b576547d760da756a.png)LSET key index value 通过索引设置列表元素的值（需要保证现有列表和下标存在，⼀般作为更新操作）

![](1.Redis%E7%AC%94%E8%AE%B0.assets/8c46d616bde7f5959e9f9d6fd1ca4f86.png)![](media/61b7a6d761fb9a5b576547d760da756a.png)LINSERT key BEFORE\|AFTER pivot value 在列表的元素前或者后插⼊元素 BLPOP key1 key2 timeout 移出并获取列表的第⼀个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为⽌。

![](media/61b7a6d761fb9a5b576547d760da756a.png)BRPOP key1 key2 timeout 移出并获取列表的最后⼀个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为⽌。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/9d7c765a9496f4dbd420214a360d3529.png)

1.  "three"
2.  "two"
3.  "one"
4.  "four"
5.  127.0.0.1:6379\>

    20

6.  \# LPOP key RPOP key
7.  127.0.0.1:6379\> lpop list 1
8.  "three"
9.  127.0.0.1:6379\> lpop list 2
10. "two"
11. "one"
12. 127.0.0.1:6379\> rpop list 1
13. "four"
14. 127.0.0.1:6379\>

    30

15. \# LINDEX LLEN
16. 127.0.0.1:6379\> lpush list one
17. (integer) 1
18. 127.0.0.1:6379\> lpush list two three \# 添加多个元素
19. (integer) 3
20. 127.0.0.1:6379\> lrange list 0 -1
21. "three"
22. "two"
23. "one"
24. 127.0.0.1:6379\> lindex list 1
25. "two"
26. 127.0.0.1:6379\> llen list
27. (integer) 3
28. 127.0.0.1:6379\>

    45

29. \# LREM
30. 127.0.0.1:6379\> lpush list two
31. (integer) 4
32. 127.0.0.1:6379\> lrange list 0 -1
33. "two"
34. "three"
35. "two"
36. "one"
37. 127.0.0.1:6379\> lrem list 2 two
38. (integer) 2
39. 127.0.0.1:6379\> lrange list 0 -1
40. "three"
41. "one"
42. 127.0.0.1:6379\>

    60

43. \#LTRIM
44. 127.0.0.1:6379\> Rpush list "qf1"
45. (integer) 1
46. 127.0.0.1:6379\> Rpush list qf2
47. (integer) 2
48. 127.0.0.1:6379\> Rpush list qf3
49. (integer) 3
50. 127.0.0.1:6379\> lrange list 0 -1
51. "qf1"
52. "qf2"
53. "qf3"
54. 127.0.0.1:6379\> ltrim list 1 2 \# 根据下标截取指定⻓度数据
55. OK
56. 127.0.0.1:6379\> lrange list 0 -1
57. "qf2"
58. "qf3"
59. 127.0.0.1:6379\>

    78

60. \#RPOPLPUSH
61. 127.0.0.1:6379\> rpush qlist one two three four \# 添加数据
62. (integer) 4
63. 127.0.0.1:6379\> lrange qlist 0 -1 \# 查看全部数据
64. "one"
65. "two"
66. "three"
67. "four"
68. 127.0.0.1:6379\> rpoplpush qlist flist \# 组合命令，将qlist最后⼀个元素移动⾄flist

| 88  | "four"                                                              |                                       |    |                          |
|-----|---------------------------------------------------------------------|---------------------------------------|----|--------------------------|
| 89  | 127.0.0.1:6379\>                                                    | lrange qlist                          | 0  | -1 \# 查看两个数据的元素 |
| 90  | 1) "one"                                                            |                                       |    |                          |
| 91  | 2) "two"                                                            |                                       |    |                          |
| 92  | 3) "three"                                                          |                                       |    |                          |
| 93  | 127.0.0.1:6379\>                                                    | lrange flist                          | 0  | -1                       |
| 94  | 1) "four"                                                           |                                       |    |                          |
| 95  | 127.0.0.1:6379\>                                                    |                                       |    |                          |
| 96  |                                                                     |                                       |    |                          |
| 97  | \# EXISTS                                                           |                                       |    |                          |
| 98  | 127.0.0.1:6379\>                                                    | exists qlist                          | \# | 查看数据是否存在         |
| 99  | (integer) 1                                                         |                                       |    |                          |
| 100 | 127.0.0.1:6379\>                                                    | exists flist                          |    |                          |
| 101 | (integer) 1                                                         |                                       |    |                          |
| 102 | 127.0.0.1:6379\>                                                    | flushdb                               |    |                          |
| 103 | OK                                                                  |                                       |    |                          |
| 104 | 127.0.0.1:6379\>                                                    | exists qlist                          |    |                          |
| 105 | (integer) 0                                                         |                                       |    |                          |
| 106 |                                                                     |                                       |    |                          |
| 107 | \# LSET                                                             |                                       |    |                          |
| 108 | 127.0.0.1:6379\>                                                    | lset mylist 0 one \# mylist不存在报错 |    |                          |
| 109 | (error) ERR no such key                                             |                                       |    |                          |
| 110 | 127.0.0.1:6379\> rpush mylist one two three                         |                                       |    |                          |
| 111 | (integer) 3                                                         |                                       |    |                          |
| 112 | 127.0.0.1:6379\> lset mylist 3 hello \# 3下标不存在报错             |                                       |    |                          |
| 113 | (error) ERR index out of range                                      |                                       |    |                          |
| 114 | 127.0.0.1:6379\> lset mylist 2 hello                                |                                       |    |                          |
| 115 | OK                                                                  |                                       |    |                          |
| 116 |                                                                     |                                       |    |                          |
| 117 | \# LINSERT                                                          |                                       |    |                          |
| 118 | 127.0.0.1:6379\> lrange mylist 0 -1 \# 全部数据                     |                                       |    |                          |
| 119 | 1) "one"                                                            |                                       |    |                          |
| 120 | 2) "two"                                                            |                                       |    |                          |
| 121 | 3) "hello"                                                          |                                       |    |                          |
| 122 | 127.0.0.1:6379\> linsert mylist after hello qf \# 在hello后⾯添加qf |                                       |    |                          |
|     | 数据                                                                |                                       |    |                          |
| 123 | (integer) 4                                                         |                                       |    |                          |

124 127.0.0.1:6379\> lrange mylist 0 -1

125 1) "one"

126 2) "two"

1.  "hello"
2.  "qf"
3.  127.0.0.1:6379\> linsert mylist before hello qf \# 在hello前⾯添加qf数据
4.  (integer) 5
5.  127.0.0.1:6379\> lrange mylist 0 -1
6.  "one"
7.  "two"
8.  "qf"
9.  "hello"
10. "qf"

    137

11. \# BLPOP BRPOP
12. 127.0.0.1:6379\> BLPOP list 10
13. ttl list
14. (nil)
15. (10.06s)
16. 127.0.0.1:6379\> BRPOP list 10
17. (nil)
18. (10.03s)
19. 127.0.0.1:6379\> lpop list 1
20. (nil)
21. 127.0.0.1:6379\>

    149

**List⼩节**

1.  我们可以把list看成⼀个链表，**前后中间**都可以插⼊数据
2.  如果key不存在，则创建新的list（链表）
3.  如果key存在，新增或者修改内容
4.  如果某⼀个list中没有任何数据，表示不存在（空链表）
5.  既然类似于链表，两边数据的插⼊和改动效率⾼，中间效率稍低
6.  常⽤功能：消息队列、消息排队（lpush rpop） 栈（lpush lpop）

**Redis数据类型-Set**

Redis的Set是string类型的⽆序集合。集合成员是唯⼀的，这就意味着集合中不能出现重复的数据（⽆序不重复）

###### 常⻅命令

![](1.Redis%E7%AC%94%E8%AE%B0.assets/8318cc94ffb36639dcc3a07789de2cda.png)SADD key member1 [member2] 向集合添加⼀个或多个成员

![](1.Redis%E7%AC%94%E8%AE%B0.assets/7e85fe9f15685eb9d4b1f01411474680.png)SMEMBERS key 返回集合中的所有成员

![](1.Redis%E7%AC%94%E8%AE%B0.assets/7e85fe9f15685eb9d4b1f01411474680.png)SISMEMBER key member 判断 member 元素是否是集合 key 的成员

![](1.Redis%E7%AC%94%E8%AE%B0.assets/7e85fe9f15685eb9d4b1f01411474680.png)SCARD key 获取集合的成员数

![](1.Redis%E7%AC%94%E8%AE%B0.assets/7e85fe9f15685eb9d4b1f01411474680.png)SREM key member1 [member2] 移除集合中⼀个或多个成员

![](1.Redis%E7%AC%94%E8%AE%B0.assets/7e85fe9f15685eb9d4b1f01411474680.png)SRANDMEMBER key [count] 返回集合中⼀个或多个随机数

![](1.Redis%E7%AC%94%E8%AE%B0.assets/7e85fe9f15685eb9d4b1f01411474680.png)SPOP key 移除并返回集合中的⼀个随机元素(原⼦操作，多个客户端并发访问时，每个返回的元素都是唯⼀的)

![](1.Redis%E7%AC%94%E8%AE%B0.assets/7e85fe9f15685eb9d4b1f01411474680.png)SMOVE source destination member 将 member 元素从 source 集合移动到

destination 集合

![](1.Redis%E7%AC%94%E8%AE%B0.assets/7e85fe9f15685eb9d4b1f01411474680.png)SDIFF key1 key2 返回给定所有集合的差集（两个set中不同的值，⽬前以key1为参照为）

![](1.Redis%E7%AC%94%E8%AE%B0.assets/7e85fe9f15685eb9d4b1f01411474680.png)SINTER key1 key2 返回给定所有集合的交集（两个set中相同的值）

![](1.Redis%E7%AC%94%E8%AE%B0.assets/7e85fe9f15685eb9d4b1f01411474680.png)SUNION key1 key2 返回所有给定集合的并集 （两个set中所有的值，重复的只有

⼀个）

![](1.Redis%E7%AC%94%E8%AE%B0.assets/71a21561cf78cd5d27afae753b30cff5.png)SDIFF、SINTER、SUNION 这些命令就可以完成 共同好友、共同爱好等类似的功能，⽐如将⽤户的关注的⼈关注放⼊到set中，即可完成“共同关注”功能

![](1.Redis%E7%AC%94%E8%AE%B0.assets/7e85fe9f15685eb9d4b1f01411474680.png)SDIFFSTORE destination key1 key2 返回给定所有集合的差集并存储在

destination 中

![](media/61b7a6d761fb9a5b576547d760da756a.png)SINTERSTORE destination key1 key2 返回给定所有集合的交集并存储在

destination 中

![](1.Redis%E7%AC%94%E8%AE%B0.assets/2bcea79acdcecfabdaff1351341b27fe.png)SUNIONSTORE destination key1 key2 所有给定集合的并集存储在 destination 集合中

由于Set类型的特性，它经常被⽤来实现标签系统，好友关系，粉丝关系等功能。

1.  \# SADD SMEMBERS SISMEMBER
    1.  127.0.0.1:6379\> sadd myset aaa
    2.  (integer) 1
    3.  127.0.0.1:6379\> sadd myset bbb
    4.  (integer) 1
    5.  127.0.0.1:6379\> sadd myset ccc
    6.  (integer) 1
    7.  127.0.0.1:6379\> smembers myset
    8.  "bbb"
    9.  "aaa"
    10. "ccc"
    11. 127.0.0.1:6379\> sismember myset aaa
    12. (integer) 1

        14

2.  \# SCARD
3.  127.0.0.1:6379\> scard myset
4.  (integer) 3

    18

5.  \# SREM
6.  127.0.0.1:6379\> SMEMBERS myset
7.  "bbb"
8.  "aaa"
9.  "ccc"
10. 127.0.0.1:6379\> SREM myset aaa
11. (integer) 1
12. 127.0.0.1:6379\> SMEMBERS myset
13. "bbb"
14. "ccc"

    29

    30 \# SRANDMEMBER

| 31    | 127.0.0.1:6379\>                                                   | sadd              | myset | aaa |
|-------|--------------------------------------------------------------------|-------------------|-------|-----|
| 32    | (integer) 1                                                        |                   |       |     |
| 33    | 127.0.0.1:6379\>                                                   | sadd              | myset | ccc |
| 34    | (integer) 0                                                        |                   |       |     |
| 35    | 127.0.0.1:6379\>                                                   | sadd              | myset | ddd |
| 36    | (integer) 1                                                        |                   |       |     |
| 37    | 127.0.0.1:6379\>                                                   | SRANDMEMBER myset | 2     |     |
| 38    | 1) "bbb"                                                           |                   |       |     |
| 39    | 2) "ddd"                                                           |                   |       |     |
| 40    | 127.0.0.1:6379\>                                                   | SRANDMEMBER myset | 3     |     |
| 41    | 1) "bbb"                                                           |                   |       |     |
| 42    | 2) "ccc"                                                           |                   |       |     |
| 43    | 3) "ddd"                                                           |                   |       |     |
| 44 45 | \# SPOP                                                            |                   |       |     |
| 46    | 127.0.0.1:6379\>                                                   | SPOP myset 1      |       |     |
| 47    | 1) "ddd"                                                           |                   |       |     |
| 48    | 127.0.0.1:6379\>                                                   | SMEMBERS myset    |       |     |
| 49    | 1) "aaa"                                                           |                   |       |     |
| 50    | 2) "bbb"                                                           |                   |       |     |
| 51    | 3) "ccc"                                                           |                   |       |     |
| 52    |                                                                    |                   |       |     |
| 53    | \# SMOVE                                                           |                   |       |     |
| 54    | 127.0.0.1:6379\> SMOVE myset s1 aaa \# myset移动到s1 移动元素为aaa |                   |       |     |
| 55    | (integer) 1                                                        |                   |       |     |
| 56    | 127.0.0.1:6379\> SMEMBERS s1                                       |                   |       |     |
| 57    | 1) "aaa"                                                           |                   |       |     |
| 58    | 127.0.0.1:6379\> SMEMBERS myset                                    |                   |       |     |
| 59    | 1) "bbb"                                                           |                   |       |     |
| 60    | 2) "ccc"                                                           |                   |       |     |
| 61    |                                                                    |                   |       |     |
| 62    | \# SDIFF SINTER SUNION （差集、交集、并集）                        |                   |       |     |
| 63    | 127.0.0.1:6379\> SADD s1 aaa                                       |                   |       |     |
| 64    | (integer) 1                                                        |                   |       |     |
| 65    | 127.0.0.1:6379\> SADD s1 bbb                                       |                   |       |     |
| 66    | (integer) 1                                                        |                   |       |     |
| 67    | 127.0.0.1:6379\> SADD s1 ccc                                       |                   |       |     |

| 68  | (integer) 1                             |              |    |     |
|-----|-----------------------------------------|--------------|----|-----|
| 69  | 127.0.0.1:6379\>                        | SADD         | s2 | ccc |
| 70  | (integer) 1                             |              |    |     |
| 71  | 127.0.0.1:6379\>                        | SADD         | s2 | ddd |
| 72  | (integer) 1                             |              |    |     |
| 73  | 127.0.0.1:6379\>                        | SADD         | s2 | eee |
| 74  | (integer) 1                             |              |    |     |
| 75  | 127.0.0.1:6379\>                        | SDIFF s1 s2  |    |     |
| 76  | 1) "aaa"                                |              |    |     |
| 77  | 2) "bbb"                                |              |    |     |
| 78  | 127.0.0.1:6379\>                        | SINTER s1 s2 |    |     |
| 79  | 1) "ccc"                                |              |    |     |
| 80  | 127.0.0.1:6379\>                        | SUNION s1 s2 |    |     |
| 81  | 1) "ccc"                                |              |    |     |
| 82  | 2) "eee"                                |              |    |     |
| 83  | 3) "bbb"                                |              |    |     |
| 84  | 4) "aaa"                                |              |    |     |
| 85  | 5) "ddd"                                |              |    |     |
| 86  |                                         |              |    |     |
| 87  | \# SDIFFSTORE SINTERSTORE SUNIONSTORE   |              |    |     |
| 88  | 127.0.0.1:6379\> SDIFFSTORE key1 s1 s2  |              |    |     |
| 89  | (integer) 2                             |              |    |     |
| 90  | 127.0.0.1:6379\> SMEMBERS key1          |              |    |     |
| 91  | 1) "aaa"                                |              |    |     |
| 92  | 2) "bbb"                                |              |    |     |
| 93  |                                         |              |    |     |
| 94  | 127.0.0.1:6379\> SINTERSTORE key2 s1 s2 |              |    |     |
| 95  | (integer) 1                             |              |    |     |
| 96  | 127.0.0.1:6379\> SMEMBERS key2          |              |    |     |
| 97  | 1) "ccc"                                |              |    |     |
| 98  |                                         |              |    |     |
| 99  | 127.0.0.1:6379\> SUNIONSTORE key3 s1 s2 |              |    |     |
| 100 | (integer) 5                             |              |    |     |
| 101 | 127.0.0.1:6379\> SMEMBERS key3          |              |    |     |
| 102 | 1) "ccc"                                |              |    |     |
| 103 | 2) "eee"                                |              |    |     |
| 104 | 3) "bbb"                                |              |    |     |

**Hash哈希类型详解**

Redis hash 是⼀个String类型的field和value的映射表，hash特别适合⽤于存储对象。

我们可以把它想象成Map集合 key :

Redis的Hash数据类型是⽤来表示键值对映射的⼀种数据类型，通常⽤于表示对 象，如⽤户信息，商品信息等。哈希可以存储⼤量的字段-值对，并且设计得⼗分节省空间，使其成为表示数据对象的理想选择。你可以⽤哈希来表示基本对象，也可以⽤来存储⼀组计数器等多种数据。

###### 常⻅命令

![](1.Redis%E7%AC%94%E8%AE%B0.assets/6fd3449075e13dd815161864e1d1b420.png)HSET key field1 value1 field2 value2 同时将多个 field-value (域-值)对设置到哈希表 key 中

![](1.Redis%E7%AC%94%E8%AE%B0.assets/84536b1173b70f5c35c98e73d0a6f450.png)![](1.Redis%E7%AC%94%E8%AE%B0.assets/6fd3449075e13dd815161864e1d1b420.png)**注意**：Redis 4.0.0版本以后，HMSET被视为已弃⽤。请在新代码中使⽤HSET HGET key field 获取存储在哈希表中指定字段的值

![](1.Redis%E7%AC%94%E8%AE%B0.assets/6fd3449075e13dd815161864e1d1b420.png)![](1.Redis%E7%AC%94%E8%AE%B0.assets/aa6114d95c4c0d66f46bbc0d47b778c4.png)![](media/6fd3449075e13dd815161864e1d1b420.png)![](media/aa6114d95c4c0d66f46bbc0d47b778c4.png)HMGET key field1 field2 获取所有给定字段的值 HGETALL key 获取在哈希表中指定 key 的所有字段和值 HDEL key field2 field2 删除⼀个或多个哈希表字段 HLEN key 获取哈希表中字段的数量

![](media/6fd3449075e13dd815161864e1d1b420.png)HKEYS key 获取所有哈希表中的字段

![](media/6fd3449075e13dd815161864e1d1b420.png)HVALS key 获取哈希表中所有值

![](media/6fd3449075e13dd815161864e1d1b420.png)HEXISTS key field 查看哈希表 key 中，指定的字段是否存在。

![](media/e9b4585e84cdb79cf900aa9ebdb60ab7.png)HINCRBY key field increment 为哈希表 key 中的指定字段的整数值加上增量

increment（如果是负数，就是减量） 。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/6d9c63ec3f248b361b90a01a1fbb5a5e.png)HSETNX key field value 只有在字段 field 不存在时，设置哈希表字段的值（原⼦性操作）。

| 1  | \# HSET HSET HMGET HGETALL                                            |                 |
|----|-----------------------------------------------------------------------|-----------------|
| 2  | 127.0.0.1:6379\> hset hash1 key1 jerry                                |                 |
| 3  | (integer) 1                                                           |                 |
| 4  | 127.0.0.1:6379\> hget hash1 key1 \# 获取存储在哈希表中指定字段的值    |                 |
| 5  | "jerry"                                                               |                 |
| 6  | 127.0.0.1:6379\> hset hash2 key1 tom key2 zhangsan                    |                 |
| 7  | (integer) 2                                                           |                 |
| 8  | 127.0.0.1:6379\> hmget hash2 key1 key2 \# 获取所有给定字段的值        |                 |
| 9  | 1) "tom"                                                              |                 |
| 10 | 2) "zhangsan"                                                         |                 |
| 11 | 127.0.0.1:6379\> HGETALL hash2 \# 所有数据                            |                 |
| 12 | 1) "key1"                                                             |                 |
| 13 | 2) "tom"                                                              |                 |
| 14 | 3) "key2"                                                             |                 |
| 15 | 4) "zhangsan"                                                         |                 |
| 16 | 127.0.0.1:6379\> hset hash1 key1 aaa key2 bbb key3 ccc \# 如果field⼀ |                 |
|    | 致，则覆盖原有的值                                                    |                 |
| 17 | (integer) 2                                                           |                 |
| 18 | 127.0.0.1:6379\> hget hash1 key1                                      |                 |
| 19 | "aaa"                                                                 |                 |
| 20 |                                                                       |                 |
| 21 | \# HDEL                                                               |                 |
| 22 | 127.0.0.1:6379\> hset hash1 key1 a1 key2 a2 key3 a3                   |                 |
| 23 | (integer) 3                                                           |                 |
| 24 | 127.0.0.1:6379\>                                                      | HGETALL hash1   |
| 25 | 1) "key1"                                                             |                 |
| 26 | 2) "a1"                                                               |                 |
| 27 | 3) "key2"                                                             |                 |
| 28 | 4) "a2"                                                               |                 |
| 29 | 5) "key3"                                                             |                 |
| 30 | 6) "a3"                                                               |                 |
| 31 | 127.0.0.1:6379\>                                                      | HDEL hash1 key1 |

1.  (integer) 1
2.  127.0.0.1:6379\> HGETALL hash1
3.  "key2"
4.  "a2"
5.  "key3"
6.  "a3"

    38

7.  \# HLEN HKEYS HVALS
8.  127.0.0.1:6379\> HLEN hash1
9.  (integer) 2
10. 127.0.0.1:6379\> HKEYS hash1
11. "key2"
12. "key3"
13. 127.0.0.1:6379\> HVALS hash1
14. "a2"
15. "a3"
16. 127.0.0.1:6379\>

    49

17. \# HEXISTS
18. 127.0.0.1:6379\> HEXISTS hash1 key2
19. (integer) 1
20. 127.0.0.1:6379\>

    54

21. \# HINCRBY 增量 负数为减量
22. 127.0.0.1:6379\> HSET hash2 k1 1 k2 2
23. (integer) 2
24. 127.0.0.1:6379\> HGETALL hash2
25. "k1"
26. "1"
27. "k2"
28. "2"
29. 127.0.0.1:6379\> HINCRBY hash2 k1 1
30. (integer) 2
31. 127.0.0.1:6379\> hget hash2 k1
32. "2"
33. 127.0.0.1:6379\> HINCRBY hash2 k1 -1
34. (integer) 1

**Redis数据类型-Zset（Sorted Set）**

在Redis中，ZSET（有序集合）是⼀种复合类型的数据结构，它将Set和Hash两种数据结构进⾏了结合，类似于Java的TreeMap（实际上是SkipList实现）。

在ZSET中，每个元素都是唯⼀的（就像Set），但每个元素关联了⼀个socre（就像

Hash中的Value）。

这个socre（分数）⽤于对元素进⾏从⼩到⼤的排序。

可以简单理解为在set的基础上，增加了⼀个值，例如： zset k1 score v1

特点：可排序、元素不重复、查询速度快

由于这个特点所以Zset经常被⽤于排⾏榜类型的功能

**注意：所有的排序默认都是升序排序，如果需要降序需要在Z后⾯加上REV常⽤命令**

![](1.Redis%E7%AC%94%E8%AE%B0.assets/62544afeb42e83e308d5f86d7bc26a10.png)ZADD key score member [score member ...] 向有序集合添加⼀个或多个成员，或者更新已存在成员的分数。

![](media/61b7a6d761fb9a5b576547d760da756a.png)ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合指定区间内的成员。成员按分数值递增(从⼩到⼤)来排列。

![](media/61b7a6d761fb9a5b576547d760da756a.png)ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 通过分数返回有序集合指定区间内的成员(分数可以采⽤正负⽆穷⼤ -inf +inf)。

![](media/61b7a6d761fb9a5b576547d760da756a.png)![](1.Redis%E7%AC%94%E8%AE%B0.assets/2bcea79acdcecfabdaff1351341b27fe.png)ZREM key member 从有序集合中删除⼀个成员。 ZCARD key 返回有序集合的成员数量

![](media/61b7a6d761fb9a5b576547d760da756a.png)![](media/61b7a6d761fb9a5b576547d760da756a.png)ZCOUNT key min max 返回有序集合中分数在给定范围内的成员数量。 ZSCORE key member 返回有序集合中指定成员的分数。

1.  \# ZADD ZRANGE
2.  127.0.0.1:6379\> ZADD myset 1 one 2 two
3.  (integer) 2
4.  127.0.0.1:6379\> ZRANGE myset 0 -1
5.  "one"
6.  "two"
7.  127.0.0.1:6379\> ZADD myset 3 three 4 four
8.  (integer) 2
9.  127.0.0.1:6379\> ZRANGE myset 0 -1
10. "one"
11. "two"
12. "three"
13. "four"
14. \# ZREVRANGE 增加withscores参数显示score
15. 127.0.0.1:6379\> ZREVRANGE myset 0 -1 withscores
16. "four"
17. "4"
18. "three"
19. "3"
20. "two"
21. "2"
22. "one"
23. "1"
24. \# ZREVRANGE 倒序
25. 127.0.0.1:6379\> ZREVRANGE myset 0 -1
26. "four"
27. "three"
28. "two"

| 29                                                                                                                                                                                                                                                                                                                                                               | 4) "one"         |                                                           |
|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------|-----------------------------------------------------------|
| 30                                                                                                                                                                                                                                                                                                                                                               |                  |                                                           |
| 31                                                                                                                                                                                                                                                                                                                                                               | \# ZRANGEBYSCORE |                                                           |
| 32                                                                                                                                                                                                                                                                                                                                                               | 127.0.0.1:6379\> | ZRANGEBYSCORE myset -inf +inf                             |
| 33                                                                                                                                                                                                                                                                                                                                                               | 1) "one"         |                                                           |
| 34                                                                                                                                                                                                                                                                                                                                                               | 2) "two"         |                                                           |
| 35                                                                                                                                                                                                                                                                                                                                                               | 3) "three"       |                                                           |
| 36                                                                                                                                                                                                                                                                                                                                                               | 4) "four"        |                                                           |
| 37                                                                                                                                                                                                                                                                                                                                                               | \# ZRANGEBYSCORE | ⼀般⽤于统计某个范围内的值，⽐如成绩区间20～100的具体⼈员 |
| 38                                                                                                                                                                                                                                                                                                                                                               | 127.0.0.1:6379\> | ZADD myscore 10 aaa 20 bbb 30 ccc 50 ddd 100 eee          |
| 39                                                                                                                                                                                                                                                                                                                                                               | (integer) 5      |                                                           |
| 40                                                                                                                                                                                                                                                                                                                                                               | 127.0.0.1:6379\> | ZRANGEBYSCORE myscore 20 100                              |
| 41                                                                                                                                                                                                                                                                                                                                                               | 1) "bbb"         |                                                           |
| 42                                                                                                                                                                                                                                                                                                                                                               | 2) "ccc"         |                                                           |
| 43                                                                                                                                                                                                                                                                                                                                                               | 3) "ddd"         |                                                           |
| 44                                                                                                                                                                                                                                                                                                                                                               | 4) "eee"         |                                                           |
| 45                                                                                                                                                                                                                                                                                                                                                               | \# ZRANGEBYSCORE | 增加withscores参数显示score                               |
| 46                                                                                                                                                                                                                                                                                                                                                               | 127.0.0.1:6379\> | ZRANGEBYSCORE myset -inf +inf withscores                  |
| 47                                                                                                                                                                                                                                                                                                                                                               | 1) "one"         |                                                           |
| 48                                                                                                                                                                                                                                                                                                                                                               | 2) "1"           |                                                           |
| 49                                                                                                                                                                                                                                                                                                                                                               | 3) "two"         |                                                           |
| 50                                                                                                                                                                                                                                                                                                                                                               | 4) "2"           |                                                           |
| 51                                                                                                                                                                                                                                                                                                                                                               | 5) "three"       |                                                           |
| 52                                                                                                                                                                                                                                                                                                                                                               | 6) "3"           |                                                           |
| 53                                                                                                                                                                                                                                                                                                                                                               | 7) "four"        |                                                           |
| 54                                                                                                                                                                                                                                                                                                                                                               | 8) "4"           |                                                           |
| 55                                                                                                                                                                                                                                                                                                                                                               | \# ZRANGEBYSCORE | "LIMIT" ⼦句后的 "offset" 和 "count" 参数分别⽤于指定跳   |
| 过的成员数量和返回的成员数量。这和 SQL 的 "LIMIT" 和 "OFFSET" 关键字类似。 \# 以下的内容所表示的就是 显示myset集合中所有排序数据（正序），通过limit跳过第 1个数据，并返回接下来的3个成员。 127.0.0.1:6379\> ZRANGEBYSCORE myset -inf +inf limit 2 3 1) "three" 2) "four" 60 \# ZREVRANGEBYSCORE 倒序 127.0.0.1:6379\> ZREVRANGEBYSCORE myset +inf -inf 1) "four" |                  |                                                           |

1.  "three"
2.  "two"
3.  "one"

    67

4.  \# ZREM
5.  \#127.0.0.1:6379\> ZRANGE myset 0 -1
6.  "one"
7.  "two"
8.  "three"
9.  "four"
10. 127.0.0.1:6379\> ZREM myset four
11. (integer) 1

    76

12. \# ZCARD(成员数量)
13. 127.0.0.1:6379\> ZCARD myset
14. (integer) 3

    80

15. \# ZCOUNT(返回的是范围内的数量) 20～100成绩范围的⼈员数量
16. 127.0.0.1:6379\> ZADD myscore 10 aaa 20 bbb 30 ccc 50 ddd 100 eee
17. (integer) 5
18. 127.0.0.1:6379\> ZCOUNT myscore 20 100
19. (integer) 4

    86

20. \# ZSCORE
21. 127.0.0.1:6379\> ZSCORE myscore ccc
22. "30"

    90

其实zset对⽐set就是多了⼀个有序，所以它不仅仅可以⽤于排序，排⾏榜等功能，其实它也可以作为权重来进⾏使⽤，⽐如某⼀个数据的score为1，权重为最⾼，其他的score设置为2、3、4、5等等 以此类推，权重由1～n来进⾏排序

**Redis特殊数据类型-Geospatial地理位置**

Redis的地理空间（Geospatial）数据结构是从3.2版本开始加⼊的，主要⽤于需要地理位置的应⽤场景。这种数据结构允许⽤户将指定的地理空间位置（经度、纬度、名称）添加到指定的key中，这些数据将会存储到sorted set中，这样设计的⽬的是为了⽅便使⽤GEORADIUS或者GEORADIUSBYMEMBER命令对数据进⾏半径查询等操作。

此命令能实现类似地理位置推算、两地之间的距离、附近的⼈等功能

###### 实现原理

1、将某个地理位置的经度纬度分别转换成2进制

2、再将两个⼆进制交错合并成⼀个即可，经度占偶数位，纬度占奇数位，得到最终的⼆进制

3、将合并的⼆进制做base32编码，得到最终结果

4、将最终结果通过geohash处理后成功的将⼀个⼆维信息转换成了⼀维信息，节省存储空间，便于前缀检索

###### 相关命令

![](1.Redis%E7%AC%94%E8%AE%B0.assets/c27f4ae4168d96c96b520dda77bfe549.png)GEOADD 添加⼀个或多个地理位置元素到key中 \*\*语法：\*\*geoAdd key lng lat member lng1 lat1 member1

![](1.Redis%E7%AC%94%E8%AE%B0.assets/f7b52554ce3b41eb7e6c1dd0a1ae5582.png)要求：满⾜经度在 -180 和 180 之间，纬度在 -85.05112878 和 85.05112878 之间。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/c27f4ae4168d96c96b520dda77bfe549.png)GEODIST 返回⼀个key中指定两个位置之间的距离 \*\*语法：\*\*GeoDist key member1

member2

![](1.Redis%E7%AC%94%E8%AE%B0.assets/e2bcb9c4dcdc38b7a6142fab16c5fa4f.png)![](1.Redis%E7%AC%94%E8%AE%B0.assets/f7b52554ce3b41eb7e6c1dd0a1ae5582.png)![](media/f7b52554ce3b41eb7e6c1dd0a1ae5582.png)![](media/f7b52554ce3b41eb7e6c1dd0a1ae5582.png)m表示单位为⽶ km表示单位为千⽶ mi表示单位为英⾥ ft表示单位为英尺

![](1.Redis%E7%AC%94%E8%AE%B0.assets/c27f4ae4168d96c96b520dda77bfe549.png)GEOPOS 返回⼀个或多个位置的经纬度信息 \*\*语法：\*\*Geopos key member1

member2

![](1.Redis%E7%AC%94%E8%AE%B0.assets/c145b162516fd2f9d31894cb3be3e147.png)GEOSEARCH 命令允许你从⼀个给定的地理位置开始，查询在⼀个给定半径内的元素。此外，你可以指定搜索区域的形状为圆形（BYRADIUS）或矩形

（BYBOX）。

###### ![](1.Redis%E7%AC%94%E8%AE%B0.assets/601486743da50f563c61abbe4d442996.png)语法：

![](1.Redis%E7%AC%94%E8%AE%B0.assets/07c5722f787e367a1abc4f8499b9b506.png)

⼀个元素。

：从键中的⼀个元素开始搜索。

是键中的

![](1.Redis%E7%AC%94%E8%AE%B0.assets/87bf2092b5098a1163e195fe1089cfd3.png)：从指定的经度和纬度开始搜索。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/87bf2092b5098a1163e195fe1089cfd3.png)：按半径搜索。 radius 是半径，单位可以是⽶（m）、公⾥（km）、英尺（ft）或英⾥（mi）。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/87bf2092b5098a1163e195fe1089cfd3.png)

：按矩形搜索。 和

分别是矩形的宽度和⾼度，单位可以是⽶（m）、公⾥（km）、英尺（ft）或英⾥（mi）。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/87bf2092b5098a1163e195fe1089cfd3.png)：返回元素的经度和纬度。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/87bf2092b5098a1163e195fe1089cfd3.png)：返回元素到中⼼的距离。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/87bf2092b5098a1163e195fe1089cfd3.png)：返回元素的 geohash。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/87bf2092b5098a1163e195fe1089cfd3.png)COUNT count [ANY] ：返回的元素数量。如果指定了到了 count 个元素就⽴即返回。

，那么只要找

![](1.Redis%E7%AC%94%E8%AE%B0.assets/87bf2092b5098a1163e195fe1089cfd3.png)

：按距离排序。

是升序，

是降序。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/07c5722f787e367a1abc4f8499b9b506.png)：将返回的元素存储到⼀个键中。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/87bf2092b5098a1163e195fe1089cfd3.png)：将返回的元素的距离存储到⼀个键中。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/07c5722f787e367a1abc4f8499b9b506.png)注意， FROMMEMBER 和

BYBOX 也必须指定其中之⼀。

必须指定其中之⼀， 和

![](media/61b7a6d761fb9a5b576547d760da756a.png)GEOSEARCHSTORE 命令是 GEOSEARCH命令的⼀个扩展。该命令将 GEOSEARCH命令的返回值存储在⼀个键中。这可以提⾼效率，因为你可以在不必重新计算相同的 GEOSEARCH 结果的情况下，重复使⽤这些结果。

###### ![](1.Redis%E7%AC%94%E8%AE%B0.assets/457ed383673725f17fbea813f411a871.png)语法：

![](1.Redis%E7%AC%94%E8%AE%B0.assets/9cd94677274b66be057c16c24cb6a9e3.png)说明：所有的选项都和 命令⼀样，只是前⾯多了两个参数

![](1.Redis%E7%AC%94%E8%AE%B0.assets/e8567c2f6c40f8f7d92f929c7a32f542.png)

![](1.Redis%E7%AC%94%E8%AE%B0.assets/e8567c2f6c40f8f7d92f929c7a32f542.png)

使⽤

：将结果存储到这个键中。

：源键，要从这个键中搜索元素。

命令时需要注意，如果 destkey 已经存在，那么

![](1.Redis%E7%AC%94%E8%AE%B0.assets/e8567c2f6c40f8f7d92f929c7a32f542.png)这个命令会覆盖它。所以，如果你要保留 destkey 的原有值，需要提前做好备份。

这⾥我们为了⽅便演示，⼤家可以访问这个⽹站来查询城市的经纬度： [**http://jingw**](http://jingw/) **eidu.757dy.com/**

| 4 | 127.0.0.1:6379\> | GEOADD | city | 116.405285 | 39.904989 | beijing  |
|---|------------------|--------|------|------------|-----------|----------|
| 5 | (integer) 1      |        |      |            |           |          |
| 6 | 127.0.0.1:6379\> | GEOADD | city | 117.190182 | 39.125596 | tianjin  |
| 7 | (integer) 1      |        |      |            |           |          |
| 8 | 127.0.0.1:6379\> | GEOADD | city | 121.472644 | 31.231706 | shanghai |

| 12 1) 1) | "116.40528291463851929" |
|----------|-------------------------|
| 13 2)    | "39.90498842291249559"  |
| 14 2) 1) | "117.19018310308456421" |

| 15 2)    | "39.12559715251200032"  |
|----------|-------------------------|
| 16 3) 1) | "106.50495976209640503" |
| 17 2)    | "29.53315530684997015"  |
| 18 4) 1) | "121.47264629602432251" |
| 19 2)    | "31.23170490709807012"  |

20

1.  \# GEODIST 可以实现的功能：返回两个⼈之间的距离
2.  127.0.0.1:6379\> GEODIST city beijing tianjin
3.  "109775.3239"
4.  127.0.0.1:6379\> GEODIST city beijing tianjin km \#带单位km
5.  "109.7753"

    26

6.  \# GEOSEARCH 以给定位置为中⼼，搜索给定的半径范围的定位 此命令可以做附近的⼈等功能
7.  \# 返回给定key中 beijing 元素 半径为500km 内搜索的内容
8.  127.0.0.1:6379\> GEOSEARCH city FROMMEMBER beijing BYRADIUS 500 km
9.  "beijing"
10. "tianjin"
11. \# asc默认正序（从近到远）withcoord输出⽬标经纬度
12. 127.0.0.1:6379\> GEOSEARCH city FROMMEMBER beijing BYRADIUS 500 km

    asc withcoord

13. "beijing"

    35 2) 1) "116.40528291463851929"

    36 2) "39.90498842291249559"

    37 2) 1) "tianjin"

    38 2) 1) "117.19018310308456421"

    39 2) "39.12559715251200032"

14. \# desc倒序（从远到近）
15. 127.0.0.1:6379\> GEOSEARCH city FROMMEMBER beijing BYRADIUS 500 km

    desc

16. "tianjin"
17. "beijing"
18. \# withdist 显示制定半径单位的距离
19. 127.0.0.1:6379\> GEOSEARCH city FROMMEMBER beijing BYRADIUS 500 km

    asc withdist

20. "beijing"

    47 2) "0.0000"

注意：因为GEO的底层就是Zset，所以完全可以使⽤Zset的命令来操作GEO

**Redis特殊数据类型-Hyperloglog基数统计**

HyperLogLog 是⼀种概率数据结构，⽤于估计集合的基数。

HLL（简称）其实代替了通过Set保存⽤户ID，统计set中元素数量来计算⽤户访问量的传统⽅式，因为我们的⽬的是为了统计独⽴⽤户访问量，⽽并⾮记录⽤户id或者

⽤户表示等数据

计算唯⼀项⽬通常需要与要计算的项⽬数量成⽐例的内存量，因为需要记住过去已经⻅过的元素，以避免多次计算它们。所以这就会导致计算基数内存量会占⽤较 多。

但是HyperLogLog实现最多使⽤12KB内存，就可以计算进阶2\^64个不同元素的基数。

每个HyperLogLog只会根据输⼊元素来计算基数，⽽本身不会储存元素，所以HLL不能像其他集合那样返回各个元素本身。

基数：⽤于统计⼀个集合中不重复的元素个数，其本身就是对集合去重后，统计剩余元素的个数

注意：HLL官⽅说明中提出了，会有标准0.81%的误差，但是在⼤数据统计的时候可以忽略不计

###### 常⻅使⽤场景

统计⽹站的访问uv（⽹站独⽴⽤户访问量）

![](1.Redis%E7%AC%94%E8%AE%B0.assets/a1ce36164dfa3edb1dbe00a23d715a58.png)当前⻚⾯独⽴访问次数统计

![](1.Redis%E7%AC%94%E8%AE%B0.assets/a1ce36164dfa3edb1dbe00a23d715a58.png)⼀⾸歌曲的独⽴⽤户播放⼈数

![](1.Redis%E7%AC%94%E8%AE%B0.assets/a1ce36164dfa3edb1dbe00a23d715a58.png)⼀个视频的独⽴⽤户观看⼈数

###### 相关命令

![](1.Redis%E7%AC%94%E8%AE%B0.assets/12cab5004b868974ab88855097cd501c.png)![](1.Redis%E7%AC%94%E8%AE%B0.assets/a1ce36164dfa3edb1dbe00a23d715a58.png)PFADD key element [element...] 添加指定元素到HyperLogLog中 PFCOUNT 返回给定HyperLogLog的基数估算值

![](1.Redis%E7%AC%94%E8%AE%B0.assets/a1ce36164dfa3edb1dbe00a23d715a58.png)PFMERGE 将多个HyperLogLog合并为⼀个HLL

**Redis特殊数据类型-BitMaps**

Redis的Bitmaps是⼀种紧凑的数据结构，⽤于存储⼆进制逻辑和状态。然⽽，需要注意的是，Bitmaps并不是实际的数据类型，⽽是定义在String类型上的⼀组位操作。

简单理解Bitmaps其实就是通过 位来保存⼆进制数据，通过0 1的⽅式来表示两种状态。

###### 适合的场景

![](media/6fd3449075e13dd815161864e1d1b420.png)![](media/6fd3449075e13dd815161864e1d1b420.png)钉钉打卡 0表示未打卡 1表示打卡登录状态

⼀个byte（字节）为8位

###### 例⼦

统计某个员⼯⼀周的打卡情况

0表示未打卡

1表示打卡

![](1.Redis%E7%AC%94%E8%AE%B0.assets/8287dd389c37049814c368bcd29a3673.png)

按照这个逻辑就算是统计⽤户⼀年的打卡情况，内存的使⽤量也⾮常少

365 = 365bit 1byte=8bit 总量：46byte

###### 相关命令

![](1.Redis%E7%AC%94%E8%AE%B0.assets/4dc30ec62da1072b60358bfd3bedcd9a.png)![](media/4dc30ec62da1072b60358bfd3bedcd9a.png)SETBIT key offset val 命令在提供的偏移处（offset）将位设置为0或1 GETBIT key offset 此命令返回给定偏移处的位的值

![](1.Redis%E7%AC%94%E8%AE%B0.assets/c145b162516fd2f9d31894cb3be3e147.png)BITOP operation destkey key [key ...] 命令可以在⼀个或多个字符串上执⾏位运算，包括AND、OR、XOR和NOT操作

![](1.Redis%E7%AC%94%E8%AE%B0.assets/ce3de1b5091bc64e67c39f74930bffea.png): 这是按位与操作。在每⼀位上，如果两个数字都为1，结果就是1，否

则是0。例如， 结果为 。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/d9bd1bf1fe2ba61e1e258799030a1d7b.png)

: 这是按位或操作。在每⼀位上，如果任何⼀个数字为1，结果就是1，

否则是0。例如， 结果为 。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/d9bd1bf1fe2ba61e1e258799030a1d7b.png)

: 这是按位异或操作。在每⼀位上，如果两个数字不相同，结果就是

1，否则是0。例如， 结果为 。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/d9bd1bf1fe2ba61e1e258799030a1d7b.png)

: 这是按位⾮操作。这个操作将输⼊键的每个位反转（0变为1，1变为

0）。例如， 结果为 。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/6d9c63ec3f248b361b90a01a1fbb5a5e.png)BITCOUNT key start end 这个命令⽤于报告设置为1的位的数量

![](1.Redis%E7%AC%94%E8%AE%B0.assets/d9bd1bf1fe2ba61e1e258799030a1d7b.png)注意： 和end 参数定义了要检查的字节范围（不是位的范围）

![](1.Redis%E7%AC%94%E8%AE%B0.assets/d9bd1bf1fe2ba61e1e258799030a1d7b.png)这两个参数都是基于字节的，⽽不是基于位的。也就是说，如果你有⼀个包

含8位的字符串，

和

将只检查第⼀个字节（即前8位）

![](1.Redis%E7%AC%94%E8%AE%B0.assets/c145b162516fd2f9d31894cb3be3e147.png)STRLEN key ⽤于统计占⽤的字节数

| 1  | \# SETBIT 记录⽤户⼀周的打卡     |   |   |
|----|----------------------------------|---|---|
| 2  | 127.0.0.1:6379\> SETBIT week     | 0 | 1 |
| 3  | (integer) 0                      |   |   |
| 4  | 127.0.0.1:6379\> SETBIT week     | 1 | 1 |
| 5  | (integer) 0                      |   |   |
| 6  | 127.0.0.1:6379\> SETBIT week     | 2 | 0 |
| 7  | (integer) 0                      |   |   |
| 8  | 127.0.0.1:6379\> SETBIT week     | 3 | 1 |
| 9  | (integer) 0                      |   |   |
| 10 | 127.0.0.1:6379\> SETBIT week     | 4 | 0 |
| 11 | (integer) 0                      |   |   |
| 12 | 127.0.0.1:6379\> SETBIT week     | 5 | 0 |
| 13 | (integer) 0                      |   |   |
| 14 | 127.0.0.1:6379\> SETBIT week     | 6 | 1 |
| 15 | (integer) 0                      |   |   |
| 16 |                                  |   |   |
| 17 | \# GETBIT 具体获取某⼀天是否打卡 |   |   |
| 18 | 127.0.0.1:6379\> GETBIT week     | 0 |   |
| 19 | (integer) 1                      |   |   |

| 20    | 127.0.0.1:6379\>                                                                 | GETBIT | week   | 1 |   |
|-------|----------------------------------------------------------------------------------|--------|--------|---|---|
| 21    | (integer) 1                                                                      |        |        |   |   |
| 22    | 127.0.0.1:6379\>                                                                 | GETBIT | week   | 2 |   |
| 23    | (integer) 0                                                                      |        |        |   |   |
| 24    | 127.0.0.1:6379\>                                                                 | GETBIT | week   | 3 |   |
| 25    | (integer) 1                                                                      |        |        |   |   |
| 26    |                                                                                  |        |        |   |   |
| 27    | \# BITCOUNT 统计这⼀周打卡次数 start end可以限定范围                             |        |        |   |   |
| 28    | 127.0.0.1:6379\> BITCOUNT week                                                   |        |        |   |   |
| 29    | (integer) 4                                                                      |        |        |   |   |
| 30 31 | 127.0.0.1:6379\> BITCOUNT week 0 0 \# ⽬前只有⼀个字节，所以start是0 (integer) 4 | end都  |        |   |   |
| 32    |                                                                                  |        |        |   |   |
| 33    | \# STRLEN 查看占⽤字节                                                           |        |        |   |   |
| 34    | 127.0.0.1:6379\> STRLEN week                                                     |        |        |   |   |
| 35    | (integer) 1                                                                      |        |        |   |   |
| 36    |                                                                                  |        |        |   |   |
| 37    | \# BITOP 可以⽤于联合统计 ⽐如查询出连续两天登录的⽤户有⼏个                     |        |        |   |   |
| 38    | \# 1号⽤户                                                                       |        |        |   |   |
| 39    | 127.0.0.1:6379\>                                                                 | SETBIT | user:1 | 0 | 1 |
| 40    | (integer) 0                                                                      |        |        |   |   |
| 41    | 127.0.0.1:6379\>                                                                 | SETBIT | user:1 | 1 | 1 |
| 42    | (integer) 0                                                                      |        |        |   |   |
| 43    | 127.0.0.1:6379\>                                                                 | SETBIT | user:1 | 2 | 1 |
| 44    | (integer) 0                                                                      |        |        |   |   |
| 45    | 127.0.0.1:6379\>                                                                 | SETBIT | user:1 | 3 | 0 |
| 46    | (integer) 0                                                                      |        |        |   |   |
| 47    | \# 2号⽤户                                                                       |        |        |   |   |
| 48    | 127.0.0.1:6379\>                                                                 | SETBIT | user:2 | 0 | 0 |
| 49    | (integer) 0                                                                      |        |        |   |   |
| 50    | 127.0.0.1:6379\>                                                                 | SETBIT | user:2 | 1 | 0 |
| 51    | (integer) 0                                                                      |        |        |   |   |
| 52    | 127.0.0.1:6379\>                                                                 | SETBIT | user:2 | 2 | 1 |
| 53    | (integer) 0                                                                      |        |        |   |   |
| 54    | 127.0.0.1:6379\>                                                                 | SETBIT | user:2 | 3 | 0 |
| 55    | (integer) 0                                                                      |        |        |   |   |

**redis事务**

Redis事务⼀次可以执⾏多条命令，按照命令的顺序进⾏串⾏化执⾏，执⾏命令的时候不允许其他命令插⼊，不许加塞。（保证原⼦性）

⼀个 Redis 事务从开始（MULTI）到执⾏（EXEC）的过程，这段时间内所有的命令都会被序列化、⼊队，在 EXEC 命令被调⽤时⼀次性、按顺序地执⾏。

**Redis 事务可以通过以下四个命令来实现：**

1.  **MULTI**：它标记了⼀个事务块的开始。MULTI 命令之后的所有命令不会⽴即执

    ⾏，⽽是缓存在服务器的⼀个事务队列中，然后当 EXEC 命令被调⽤时⼀次性、按顺序地执⾏。

2.  **EXEC**：它标记事务的提交，它的作⽤是触发服务器执⾏所有在 MULTI 之后⼊队的命令。
3.  **DISCARD**：如果客户端在 MULTI 之后决定取消事务，那么它可以调⽤ DISCARD命令来做这件事。调⽤ DISCARD 之后，服务器会清空事务队列，并将客户端的状态从事务状态调整回⾮事务状态。
4.  **WATCH key [key ...]**：WATCH 命令⽤于在执⾏事务前监控⼀个或多个键，以此来达到乐观锁的效果。如果在调⽤ EXEC 命令执⾏事务之前，有其他客户端抢

先对任何⼀个被监视的键进⾏了替换、更新、删除等操作，那么当客户端尝试执⾏事务时，服务器将返回⼀个错误，客户端可以在这时选择重试事务或者放弃事务。

\*\*注意：\*\*Redis 的事务不⽀持回滚，即如果事务执⾏过程中出现错误，Redis 只是简单地停⽌执⾏后续的命令，但是不会回滚已经执⾏的命令。

Redis 的事务虽然简单，但是由于其原⼦性，通常⾜够应对绝⼤部分需要使⽤事务的场景。

**Redis事务-失败演示**

Redis事务会将命令按照顺序执⾏串⾏化操作，但是如果这些命令中有⼀个命令失败了是否会影响到整个事务的执⾏，也就是事务中断或者取消？

答案：不会，只有错误（⾮语法错误）的命令不会执⾏

1.  \# 在⼀个redis事务中，如果出现了错误的命令，只有错误的命令不会执⾏，但不会影响整体事务执⾏
    1.  127.0.0.1:6379\> MULTI
    2.  OK
    3.  127.0.0.1:6379(TX)\> set num 10
    4.  QUEUED
    5.  127.0.0.1:6379(TX)\> set str abc
    6.  QUEUED
    7.  127.0.0.1:6379(TX)\> INCR num
    8.  QUEUED
    9.  127.0.0.1:6379(TX)\> INCR str \# 错误的命令
    10. QUEUED
    11. 127.0.0.1:6379(TX)\> get num
    12. QUEUED
    13. 127.0.0.1:6379(TX)\> get str
    14. QUEUED
    15. 127.0.0.1:6379(TX)\> exec
    16. OK
    17. OK
    18. (integer) 11
    19. (error) ERR value is not an integer or out of range \# 错误命令不执⾏
    20. "11"
    21. "abc"
    22. 127.0.0.1:6379\> keys \*
    23. "str"
    24. "num"

        26

以上的案例就好像我们去超市买东⻄，发现有⼀个物品过期了，那么此物品则不会结账，⽽是挑出去⼀样

Redis事务中，如果我们的命令语法都出现了错误，那么Redis事务还会执⾏吗？

**Redis事务-watch命令**

是 Redis 的⼀个事务命令，它为 Redis 提供了乐观锁（Optimistic Locking）的功能。这使得你可以在执⾏事务时添加⼀种并发控制机制。

秒杀业务就是通过Redis的watch命令来实现乐观锁实现功能

在 Redis 中， 命令可以⽤来监视⼀个或多个 key，如果在事务执⾏之前这些

key 的值发⽣了改变，那么事务将会被打断。

注意：⼀旦执⾏了

###### ⼯作流程

或

命令，所有的

监控都会被取消。

1.  ⼀个或多个 key。
2.  创建事务，即发送
3.  发送⼀系列的命令。
4.  执⾏事务，即发送

    命令。

命令。此时，如果任何被

的 key ⾃你开始

以来已被其他客户端更改，那么 将失败，事务被打断。

1.  \# 此案例演示的是并发时出现的线程安全问题
    1.  \# 客户端1 操作
    2.  \# 案例：账户a有100元 b有50元，现在要求将a账户的100元转到b账户，最终结果 a=0 b=150
    3.  127.0.0.1:6379\> set a 100
    4.  OK
    5.  127.0.0.1:6379\> set b 50
    6.  OK
    7.  127.0.0.1:6379\> MULTI
    8.  OK
    9.  127.0.0.1:6379(TX)\> DECRBY a 100
    10. QUEUED
    11. 127.0.0.1:6379(TX)\> INCRBY b 100
    12. QUEUED
    13. 127.0.0.1:6379(TX)\> get a
    14. QUEUED
    15. 127.0.0.1:6379(TX)\> get b
    16. QUEUED
    17. 127.0.0.1:6379(TX)\> EXEC \# 执⾏事务提交之前出现了另外的线程修改了a账户数据的情况
    18. (integer) -50 \# a账户结果有误
    19. (integer) 150
    20. "-50"
    21. "150"

        23

2.  \# 客户端2 操作
3.  \# 在客户端1提交事务之前，减少a账户⾦额为50
4.  127.0.0.1:6379\> get a
5.  "100"
6.  127.0.0.1:6379\> get b
7.  "50"
8.  127.0.0.1:6379\> DECRBY a 50
9.  (integer) 50
10. 127.0.0.1:6379\> get a
11. "50"
12. 127.0.0.1:6379\> get b
13. "50"

为了解决以上的并发安全问题，我们可以采⽤watch命令来监控a和b账户 就是监控

key

1.  \# 客户端1
2.  \# 需要通过watch命令监控 a与b，避免发⽣线程安全问题
3.  127.0.0.1:6379\> flushdb
4.  OK
5.  127.0.0.1:6379\> set a 100
6.  OK
7.  127.0.0.1:6379\> set b 50
8.  OK
9.  127.0.0.1:6379\> WATCH a b \# 开启监控 key a与b
10. OK
11. 127.0.0.1:6379\> MULTI
12. OK
13. 127.0.0.1:6379(TX)\> DECRBY a 100
14. QUEUED
15. 127.0.0.1:6379(TX)\> INCRBY b 50
16. QUEUED
17. 127.0.0.1:6379(TX)\> get a
18. QUEUED
19. 127.0.0.1:6379(TX)\> get b
20. QUEUED
21. 127.0.0.1:6379(TX)\> EXEC \# 在提交之前客户端2 改变了a的值，出现并发安全问题，因为有watch
22. \# 监控所以事务提交不成功，避免发⽣线程安全问题
23. (nil)

    24

24. \# 客户端2
25. \# 在客户端1事务提交之前，改变a账户的值
26. 127.0.0.1:6379\> get a
27. "100"
28. 127.0.0.1:6379\> get b
29. "50"
30. 127.0.0.1:6379\> DECRBY a 50
31. (integer) 50
32. 127.0.0.1:6379\> get a

**Redis-图形化客户端**

其实有的时候我们需要Redis像MySQL的DBeaver、Navicat那样对应的图形化客户 端，那么Redis官⽅是没有没有提供的，但是市场上还是有很多好⽤的可视化的客户端，⽐较常⻅的有：

![](1.Redis%E7%AC%94%E8%AE%B0.assets/5f11296d100585d26b1bc972db7d90d8.png)**Redis Desktop Manager (RDM):** RDM 是⼀个跨平台的桌⾯ Redis 客户端，它以图形化的⽅式展示 Redis 数据库中的数据，并且⽀持所有 Redis 命令。RDM ⽀持 Linux，Windows 和 macOS。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/5f11296d100585d26b1bc972db7d90d8.png)**FastoRedis (Fastonosql):** 这是⼀个跨平台的数据库管理⼯具，它⽀持 Redis 以及其他 NoSQL 数据库如 MongoDB，Memcached 等。FastoRedis 提供了⼀种直观的

⽅式来管理和查看你的 Redis 数据。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/5f11296d100585d26b1bc972db7d90d8.png)**Another Redis Desktop Manager:** 这是⼀款优秀的开源项⽬，由中国开发者创建。它⽀持直连/哨兵/集群连接，⽀持键值的增删改查操作，同时还提供了可视化界⾯和多语⾔⽀持。⽀持的系统包括 Windows，Mac 和 Linux。

等等。。

那么我们这⾥可以采⽤**Another Redis Desktop Manager**或者**Redis Desktop Manager (RDM)**

**Jedis客户端操作Redis**

Jedis 是⼀个流⾏的 Java 客户端库，它⽤于连接和操作 Redis 数据库。以下是 Jedis

的⼀些关键特性和详细说明：

1.  \*\*连接：\*\*Jedis 提供简单的⽅法来连接 Redis。你可以指定主机名和端⼝来连接本地或远程的 Redis 服务器。也可以使⽤密码验证功能来连接需要认证的 Redis服务器。
2.  \*\*基本操作：\*\*Jedis ⽀持所有的 Redis 命令，例如 GET、SET、DEL 等键值对操

作，以及 LPUSH、LRANGE 等列表操作，还有 SADD、SMEMBERS 等集合操作，等等。

1.  \*\*⾼级功能：\*\*Jedis ⽀持 Redis 的⼀些⾼级功能，如事务、管道和发布/订阅。事务允许你执⾏⼀组命令，然后⼀次性提交到服务器。管道允许你⼀次性发送多个命令，然后⼀次性获取所有结果，这可以显著提⾼⽹络利⽤率和性能。发 布/订阅则是⼀个强⼤的消息发布和订阅系统。
2.  \*\*连接池：\*\*Jedis 提供了⼀个连接池，它可以在多线程环境中复⽤连接，避免频繁地创建和销毁连接，提⾼了应⽤程序的性能。
3.  \*\*⼆进制安全：\*\*Jedis 是⼆进制安全的，这意味着你可以在 Redis 中存储任何类型的数据，包括字符串、整数、浮点数，甚⾄是 JPEG 图⽚或者序列化的对象。
4.  \*\*集群⽀持：\*\*从 2.9.0 版本开始，Jedis 提供了对 Redis 集群的原⽣⽀持，这包括分区、故障转移和复制等功能。

    从这节课开始我们将通过Java来连接Redis

## SpringBoot整合Redis

⼀般使⽤Redis都会配合SpringBoot来搭建微服务项⽬，所以很多时候我们需要Redis来⾼速缓存来缓存⼀些数据，来达到储存⼀些⾼频率访问的数据，所以这就需要通过官⽅提供的Jedis来实现Redis缓存达到⾼效缓存的⽬的。

**创建SpringBoot 项⽬**

**项⽬名称qfRedis**

**导⼊Jedis依赖**（SpringBoot其实可以帮助管理版本）

**编写配置application.yml**

**JedisConfig类型配置Jedis连接池**

如果我们想通过Jedis连接Redis，需要新建JedisConfig类型，来配置Jedis连接池

21

1.  @Value("\${spring.redis.jedis.pool.min-idle}")
2.  private int minIdle; 24
3.  //注⼊Jedis连接池
4.  @Bean
5.  public JedisPool jedisPool(){
6.  //连接池配置
7.  JedisPoolConfig poolConfig = new JedisPoolConfig();
8.  //读取配置
9.  poolConfig.setMaxTotal(maxActive);
10. poolConfig.setMaxIdle(maxIdle);
11. poolConfig.setMinIdle(minIdle);
12. //需要找到有密码的重载构造⽅法，我们可以看源码找到对应⽅法
13. //需要配置的参数：GenericObjectPoolConfig\<Jedis\> poolConfig,

    String host, int port, int timeout(⼀般默认2000ms), String password, int database

14. JedisPool jedisPool = new JedisPool(poolConfig,host,port,2000,password,database);
15. public void setDatabase(int database) {
16. this.database = database;

    46 }

    47

17. public String getHost() {
18. return host;

    50 }

    51

19. public void setHost(String host) {
20. this.host = host;

    54 }

**Test测试类测试**

输出结果：

![](1.Redis%E7%AC%94%E8%AE%B0.assets/2e47a1a10b3e63f0b79eb67823ce64c3.png)

**Redis完成⼿机验证码功能**

正常完成此业务需要调⽤短信验证接⼝（收费），⽐如说阿⾥云

![](1.Redis%E7%AC%94%E8%AE%B0.assets/26fe2d36aaccebe481d4e9ea5b7b3038.jpeg)

###### 整体流程

1、后台Redis⽣成⼀个key⽤于保存4位验证码，设置此key的过期时间为60m

2、前端⽤户输⼊的验证码和后台⽣成的redis key验证码进⾏⽐较如果不相等：

验证码校验失败如果相等：

恭喜您登录成功！

3、防攻击，当⽤户每次发送获取验证码请求是都在Redis中⽣成⼀个key，具体最好如下：

Redis Key：key最好是ip地址，值为发送此时，可以默认为1，当⽤户每获取⼀次验证码，进⾏+1操作，当3分钟内超过了5次访问（expire 5分钟），将当前⽤户ip存

⼊lock_ip key中，表示锁定（12⼩时）。

此时再通过此ip地址发送访问，将提示⽤户，您今天不能在获取验证码

### 完成业务

##### 获取验证码

此部分我们先来完成验证码的⽣成，发送，测试前后端联通

1.  @RestController
2.  @Slf4j
3.  @CrossOrigin
4.  public class PhoneCodeValidateController { 16
5.  // 注⼊Jedis连接池
6.  @Autowired
7.  private JedisPool jedisPool; 20

    21 /\*\*

8.  \* ⽣成随机4位验证码（调⽤⼿机号api短信接⼝）
9.  \*/
10. public int phoneCode(){
11. int num = (int)(Math.random()\*10000);
12. return num;

    27 }

    28

    29 /\*\*

13. \* 根据⽤户的⼿机号⽣成redis中的key phone:code:⼿机号
14. \* 判断key是否存在，如果key不存在对key进⾏赋值，设置过期时间为60m
15. \* 如果key存在，提示⽤户：验证码以发送请注意查收短信
16. \* @param phoneNum
17. \* @return
18. \*/
19. @GetMapping("getValidateCode")
20. public String getValidateCode(@RequestParam("phoneNum") String phoneNum){
21. //获得jedis连接
22. Jedis jedis = jedisPool.getResource();
23. //保存⼿机验证码 Redis key
24. String key = "phone:code:"+phoneNum;
25. //判断key是否存在
26. if(!jedis.exists(key)){
27. int phoneCode = this.phoneCode();
28. log.info("验证码已发送，验证码："+phoneCode);
29. jedis.set(key,phoneCode+"");
30. jedis.expire(key,60);

前端代码Ajax部分

##### 判断验证码是否正确

###### 前端点击确认登录按钮

PhoneCodeValidateController后端代码，增加接⼝⽅法，此⽅法⽤于前端输⼊验证码是否正确

**前端代码**

##### 防短信攻击

1、此处我们需要获取⽤户的ip地址，才能完成后续的业务，获取的时机在于⽤户发送获取验证码请求时，并且将ip地址⽣成Redis中的key：protectCode:具体ip

2、每次获取验证码时，判断如果key不存在（第⼀次获取验证码⽤户）进⾏ incr +1

操作，并设置过期时间5分钟，如果存在（同⼀⽤户）对当前⽣成的key进⾏ incr +1

操作

3、判断如果当前⽤户访问超过3次，⽣成Redis key：lockip:具体ip，锁定此⽤户12

⼩时⽆法获取验证码

获取验证码⽅法来获取⽤户IP

1.  @GetMapping("getValidateCode")
2.  public String getValidateCode(@RequestParam("phoneNum") String phoneNum,
3.  HttpServletRequest request){

    4 /\*\*

4.  \* 防⽌短信轰炸逻辑
5.  \* 1、根据⽤户IP⽣成Redis Key：protectCode:具体ip
6.  \* 2、每次获取验证码，判断Key是否存在
7.  \* 如果不存在：执⾏incr +1操作，并设置过期时间5分钟
8.  \* 如果存在：直接执⾏incr +1
9.  \* 3、判断如果当前⽤户访问超过3次，⽣成Redis key：lookIp:具体ip，
10. \* 锁定此⽤户12⼩时⽆法获取验证码（设置过期时间为12⼩时）
11. \*/
12. //获得jedis连接
13. Jedis jedis = jedisPool.getResource(); 15
14. //优化代码：⽤户访问进来以后，直接判断redis中是否有对应的lockip，如果

    有，直接返回

15. //IP锁定12⼩时
16. String lockIp="lockIp"+this.getProtectIp(request);
17. if(jedis.exists(lockIp)){
18. return "限制访问12⼩时后解锁";

    21 }

    22

19. //保护Key
20. String protectKey = "protectCode:"+this.getProtectIp(request);
21. //判断保护key是否存在
22. if(!jedis.exists(protectKey)){
23. //incr命令可以直接创建key

当然以上这些代码主要是为了给⼤家展示，整体流程，代码其实还有很⼤优化空间，⽐如保护验证码⽅法可以直接抽取出来。

当然这个功能还可以继续完善，⽐如⽤户如果蒙验证码的时候，我们怎么办，这个其实就需要⼤家在实际⼯作中按需求详细完成了。

## SpringBoot整合RedisTemplate

RedisTemplate是SpringDataRedis中对JedisApi的⾼度封装，提供了redis各种操作、异常处理及序列化，⽀持发布订阅。

⾸先我们要知道SpringData是Spring中数据操作的模块，包括对各种数据库的集成，⽐如我们之前学过的Spring Data JDBC、JPA等，其中有⼀个模块叫做Spring Data Redis，⽽RedisTemplate就是其中提供操作Redis的通⽤模板

官⽅⽹址： **https://spring.io/projects/spring-data**

![](1.Redis%E7%AC%94%E8%AE%B0.assets/4271861da3a71d2ac471879e57d2b542.jpeg)

Spring Data Redis中提供了如下的内容：

1、对不同Redis客户端的整合（Lettuce和Jedis） 2、提供了RedisTemplate统⼀API操作Redis

3、⽀持Redis订阅发布模型

4、⽀持Redis哨兵和集群

5、⽀持基于Lettuce的响应式编程（底层就是Netty）

6、⽀持基于JDK、JSON、字符串、Spring对象的数据序列化反序列化

**通⽤API**

在我们使⽤Jedis的时候，如果我们想要完成⼀些Redis的操作，对应的命令其实就是对应的⽅法，⽐如Set在Jedis中也就是set()⽅法，虽然很好上⼿，但是这会导致我们的代码⽐较臃肿，⽽既然SpringData出⼿整合了，它必然会按照⼀定的规律做进⼀步的封装，具体如下：

![](1.Redis%E7%AC%94%E8%AE%B0.assets/583c7c4911aca684f0656cf1b453f009.png)redisTemplate.ops...⽅法囊括了⼏乎所有的Redis不同数据类型的命令操作操作String类型数据：redisTemplate.opsForValue()

![](1.Redis%E7%AC%94%E8%AE%B0.assets/805bc0db75ef6491d674b42fa34b31bc.png)操作List数据类型：redisTemplate.opsForList()

![](1.Redis%E7%AC%94%E8%AE%B0.assets/583c7c4911aca684f0656cf1b453f009.png)![](media/583c7c4911aca684f0656cf1b453f009.png)操作Hash数据类型：redisTemplate.opsForHash()操作Set数据类型：redisTemplate.opsForSet()

![](media/583c7c4911aca684f0656cf1b453f009.png)![](media/583c7c4911aca684f0656cf1b453f009.png)操作ZSet数据类型：redisTemplate.opsForZSet() 以上这些⽅法返回的都是...Operations类型，⽐如

![](1.Redis%E7%AC%94%E8%AE%B0.assets/1483d3c86c39e29d6cb9068416816060.png)ValueOperations其中包括的就是String类型的所有操作：Set、Get等

\*\*注意：\*\*RedisTemplate中还封装着⼀些通⽤的或者特殊的操作

### 具体演示

我们会采⽤SpringBoot项⽬来进⾏演示，因为SpringBoot已经提供了对Spring Data Redis的⽀持，使⽤起来也⾮常简单，只要记住⼏点：

1、 引⼊依赖

2、简单配置

3、拿到RedisTemplate即可

我们可以在新建⼀个项⽬，⽤于演示RedisTemplate

###### 引⼊依赖

第⼀件事，我们需要导⼊RedisTemplate依赖和commons-pool连接池依赖（其实在创建SpingBoot项⽬的时候可以直接选择，不需要⼿动导⼊）

Jedis与RedisTemplate底层使⽤的连接池都是commons-pool2，所以需要导⼊它

这⾥我们可以看⼀下spring-boot-starter-data-redis底层，⼤家会惊奇的发现并没有引⼊Jedis

![](1.Redis%E7%AC%94%E8%AE%B0.assets/130a3892862b8c4915f97e2d1eaa4679.png)

\*\*原因：\*\*在SpringBoot2.x版本以后，从原来的Jedis替换成了lettuce，所以2.x以后开始默认使⽤Lettuce座位Redis客户端，Lettuce客户端基于Netty的NIO框架实现，只需要维持单⼀的连接即可⾼效⽀持业务端并发请求。同时，Lettuce⽀持的特性更加全

⾯，其性能表现并不逊于，甚⾄优于Jedis。

###### 简单理解：

![](1.Redis%E7%AC%94%E8%AE%B0.assets/28cbb716b0d5a7de3874ecc8c34bc5fb.png)![](media/28cbb716b0d5a7de3874ecc8c34bc5fb.png)Jedis：采⽤的直连，多个线程操作的话，是不安全的，如果想要避免线程安全问题，就需要使⽤JedisPool连接池，但是也会有⼀些线程过多等其他问题，类似于BIO Lettuce：底层采⽤Netty，实例可以在多个线程中进⾏共享，不存在线程安全问题！类似NIO

这⾥可以看⼀下Lettuce-core底层引⽤的包包含Netty

###### 配置⽂件

如果我们不知道具体要配置什么内容，其实可以通过源码来进⾏查看，因为所有的 SpringBoot配置类都有有⼀个⾃动装配类型，⾃动装配类型都会绑定⼀个properties配置⽂件

![](1.Redis%E7%AC%94%E8%AE%B0.assets/5bd6568d03b349908db64b7bd28f1b54.jpeg)

找到RedisAutoConfiguration ⾃动装配类型，并且找到绑定的RedisProperties

![](1.Redis%E7%AC%94%E8%AE%B0.assets/515aec70e265d237564eaf88702b6848.png)

进⼊其中我们就能看到这⾥我们需要配置什么了，包括它有哪些默认的配置

![](1.Redis%E7%AC%94%E8%AE%B0.assets/ebf430de9a116f3b35867eaa10630309.jpeg)

当然这⾥其实我们可以再看⼀下RedisAutoConfiguration类型，在这其中我们就能看到此类型具体装配的内容

配置⽂件application.xml

**拿到RedisTemplate**

测试类：

执⾏之后我们控制台成功得到了我们想要的结果

![](1.Redis%E7%AC%94%E8%AE%B0.assets/7b116c8e529e30cdb2cb60348de6bd90.jpeg)

但是如果我们通过指令来查看这个key包括值，你会发现是⼀个乱码

![](1.Redis%E7%AC%94%E8%AE%B0.assets/b4fe54588dfb0497a842ecbc6b31da8f.jpeg)

为什么会是这样那？其实这就涉及到了序列化的问题了

**RedisTemplate序列化问题**

想要解决以上的问题，我们就需要掌握RedisTemplate序列化的问题，⾸先我们现在直接进⼊RedisTemplate源码

![](1.Redis%E7%AC%94%E8%AE%B0.assets/702b1fe978c5776744cce1ea9667145e.png)

再往下看有⼀个默认的序列化器

![](1.Redis%E7%AC%94%E8%AE%B0.assets/c1a03332c82c8bc766f39b76dd9cb5a3.jpeg)

也就是说，RedisTemplate默认采⽤的是默认的JDK序列化器，这种序列化⽅式会有

⼀定的问题

1、可读性差

2、内存占⽤⼤

所以总结来说，我们就需要修改RedisSerializer的具体实现，这⾥我们可以先看⼀下 RedisSerializer的实现类有哪些，其中以下图中的两个是我们最常⽤的，因为⼀般情况下：

key：String类型 value：可能是对象，那么需要JSON的序列化⽅式

![](1.Redis%E7%AC%94%E8%AE%B0.assets/3d2c8f5453c7f937edae494df6625675.jpeg)

所以我们可以通过⾃定义RedisTemplate来解决这个问题，这个也是我们redis开发中常⽤的⼀种解决序列化问题的⽅式

**⾃定义RedisTemplate**

我们新建⼀个RedisConfig类型，以下的这个是固定模板，可以直接使⽤

1.  @Configuration
2.  public class RedisConfig {
3.  @Bean
4.  public RedisTemplate\<String,Object\> redisTemplate(RedisConnectionFactory factory){
5.  // 为了研发⽅便 key直接为String类型
6.  RedisTemplate\<String,Object\> template = new RedisTemplate\<\>();
7.  // 设置连接⼯⼚
8.  template.setConnectionFactory(factory);
9.  //序列化配置，通过JSON解析任意对象
10. GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer();
11. //设置key序列化
12. template.setKeySerializer(RedisSerializer.string());
13. template.setHashKeySerializer(RedisSerializer.string());
14. //设置value序列化
15. template.setValueSerializer(jsonRedisSerializer);
16. template.setHashKeySerializer(jsonRedisSerializer);
17. template.afterPropertiesSet();
18. return template;

    19 }

搞定以上内容以后，回到测试类来实验⼀下

![](1.Redis%E7%AC%94%E8%AE%B0.assets/c249219ee4b2f773c855a4e3b303722c.jpeg)

还可以在实验存储⼀个对象，新建⼀个User对象

测试类测试

查看Redis中(可视化⼯具查看)

![](1.Redis%E7%AC%94%E8%AE%B0.assets/eeaba8630cccfd1b3ddbe3d9735ab655.jpeg)

控制台输出对象

![](1.Redis%E7%AC%94%E8%AE%B0.assets/fd60464879592f5134d0e862006ee88e.jpeg)

这其实就实现了对象的序列化和反序列化

但是这⾥还有问题，就是JSON序列化的⽅式确实能够帮助我们⾃动的实现序列化和反序列化，主要是因为添加了@class，但是这个会导致额外的内存开销，如果在数据量特别⼤的时候就会有影响，但是如果没有@class就不会实现⾃动序列化和反序列化

#### **StringRedisTemplate**

其实实际开发中，如果为了节省空间，并不会完全使⽤JSON序列化来处理value，

⽽是统⼀采⽤String序列化器，储存Java对象也是如此，这就意味着我们需要重新编写RedisTemplate，但是SpringBoot其实提供了⼀个StringRedisTemplate，通过它我们就可以完成以上的需求

![](1.Redis%E7%AC%94%E8%AE%B0.assets/f0eb3a24ebb4b9303e755ab53e87e36b.jpeg)

那我们来演示⼀下，在测试类中

1.  @SpringBootTest
2.  class RedisTestApplicationTests { 3
3.  @Autowired
4.  private RedisTemplate\<String,Object\> redisTemplate;
5.  @Autowired
6.  private StringRedisTemplate stringRedisTemplate;
7.  .....
8.  //Json⼯具
9.  private ObjectMapper mapper = new ObjectMapper();
10. @Test
11. void StringTemplate() throws JsonProcessingException {
12. User user = new User("qf",18);
13. //⼿动序列化
14. String json = mapper.writeValueAsString(user);
15. //写⼊数据
16. stringRedisTemplate.opsForValue().set("user:2",json);

    18

17. //读取数据
18. String val = stringRedisTemplate.opsForValue().get("user:2");

### 额外

其实在企业中⽤的最多的还是RedisTemplate，那么为了解决以上的问题，其实可以再⾃定义的RedisTemplate中来进⾏解决，这⾥给⼤家提供⼀个模板，可以在企业中直接使⽤

1.  import com.fasterxml.jackson.annotation.JsonAutoDetect;
2.  import com.fasterxml.jackson.annotation.JsonTypeInfo;
3.  import com.fasterxml.jackson.annotation.PropertyAccessor;
4.  import com.fasterxml.jackson.databind.ObjectMapper;
5.  import com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeVa lidator;
6.  import org.springframework.context.annotation.Bean;
7.  import org.springframework.context.annotation.Configuration;
8.  import org.springframework.data.redis.connection.RedisConnectionFactory;
9.  import org.springframework.data.redis.core.RedisTemplate;
10. import org.springframework.data.redis.serializer.GenericJackson2JsonRedis Serializer;
11. import org.springframework.data.redis.serializer.Jackson2JsonRedisSeriali zer;
12. import org.springframework.data.redis.serializer.RedisSerializer;

    15

13. @Configuration
14. public class RedisConfig {
15. @Bean
16. public RedisTemplate\<String,Object\> redisTemplate(RedisConnectionFactory factory){
17. // 为了研发⽅便 key直接为String类型
18. RedisTemplate\<String,Object\> template = new RedisTemplate\<\>();
19. template.setConnectionFactory(factory);
20. //使⽤Jackson2JsonRedisSerializer来序列化和反序列化redis的 value值
21. Jackson2JsonRedisSerializer jsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
22. ObjectMapper mapper = new ObjectMapper();
23. mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);

**Redis持久化**

Redis是内存数据库，所以如果不把数据保存到磁盘上，服务器⼀旦进程退出，或者断电，数据就会丢失，所以Redis提供了持久化功能

![](1.Redis%E7%AC%94%E8%AE%B0.assets/6b64795ee28aac11ad9f112a7b92f4e6.png)**RDB**（Redis 数据库）：RDB 持久性以指定的时间间隔执⾏数据集的时间点快照。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/5f11296d100585d26b1bc972db7d90d8.png)**AOF**（仅追加⽂件）：AOF 持久性记录服务器接收到的每个写操作。然后可以在服务器启动时再次重播这些操作，从⽽重建原始数据集。命令使⽤与 Redis协议本身相同的格式进⾏记录。

要注意的是Redis7提供了新的持久化模式：**RDB + AOF**：可以在同⼀个实例中组合

AOF 和 RDB。

#### **RDB**

![](1.Redis%E7%AC%94%E8%AE%B0.assets/5f11296d100585d26b1bc972db7d90d8.png)![](media/5f11296d100585d26b1bc972db7d90d8.png)RDB持久化是通过创建数据的快照实现的。具体来说，Redis会在指定的时间间隔内，将内存中的数据集快照写⼊磁盘，也就是创建了⼀个数据集的副本。 这个时间间隔可以通过"save"配置选项进⾏设置，如"save 900 1"表示如果900秒

内有⾄少1个key变化，则创建⼀个snapshots快照。

![](media/61b7a6d761fb9a5b576547d760da756a.png)RDB是Redis默认的持久化⽅式，主要优点是能最⼤化Redis的性能，并且⽣成的 RDB⽂件⾮常适合⽤于全量复制、数据备份等场景。

![](media/61b7a6d761fb9a5b576547d760da756a.png)但是，如果Redis意外宕机，你可能会丢失最后⼀次快照以后修改的所有数据。

![](media/61b7a6d761fb9a5b576547d760da756a.png)rdb保存⽂件：dump.rdb 默认保存在当前运⾏⽬录

**6V7版本差异**

实际上redis6版本的配置和7版本发⽣了很⼤的变化

6.0.16以下版本

![](1.Redis%E7%AC%94%E8%AE%B0.assets/da4f07a7c4e45564705871ca066b70a5.jpeg)

6.2以及7版本

![](1.Redis%E7%AC%94%E8%AE%B0.assets/b2a14188a4c2c7cb0ca9795219ef3b9f.jpeg)

对⽐来说，公式没有太⼤的变动，但是Redis7认为，不需要那么频繁的去保存快照。

**RDB触发条件**

默认触发在服务停⽌时

###### 1、⾃动触发

在这之前我们需要先了解⼀下对应的配置

我们来演示⼀下

1、设置5秒内有2次修改触发RDB

2、改变rdb⽂件名字为 dump6379.rbd 3、⽂件⽣成为位置在 /root/opt

![](1.Redis%E7%AC%94%E8%AE%B0.assets/6a2e73a91d12d70717b21c5f9b3ef559.jpeg)

![](1.Redis%E7%AC%94%E8%AE%B0.assets/5e9b4a6b5aaa19cd2630ce8a12fd411d.jpeg)![](1.Redis%E7%AC%94%E8%AE%B0.assets/ace9210407e0c8129a229e4451b74a41.jpeg)

效果⾃动触发，⽣成⽂件：

![](1.Redis%E7%AC%94%E8%AE%B0.assets/d72f97b1784d1939ffead2ca2b6a5a12.jpeg)

###### 总结

1.  当我们redis⼀旦出现问题，服务重启，服务关闭以后，再次启动时就会读取备份⽂件，恢复数据。
2.  为了避免出现备份被删除或者丢失的问题，⼀般情况下我们会定时把redis中的备份数据迁移到别处以防⽌数据丢失。
3.  还有⼀点要注意：设置时间不能太短，加⼊1秒就备份数据，会导致⼤量的磁盘IO，造成磁盘压⼒

###### 2、⼿动触发

命令：通过save bgsave命令能够⼿动的备份数据

1、在redis中使⽤save命令，此命令有Redis主进程执⾏，会阻塞所有命令，但是这个⽅式如果数据量⼤的时候会导致效率较慢

2、所以⽐较推荐执⾏bgsave，此命令会开启⼦进程执⾏rdb，避免主进程受影响

（⽣产必须⽤这个命令）

演示：此时我们在5秒内只修改⼀条数据，此时备份不会⽣效，但是如果我就想保存这条数据，就可以通过save或者bgsave命令来保存

bgsave命令：redis会在后台异步进⾏快照操作，**不阻塞**快照同时还可以相应客户端请求，该触发⽅式会fork⼀个⼦进程由⼦进程复制持久化过程

**fork流程**

主进程执⾏读操作时，⼦进程共享内存

主进程⼀旦执⾏修改操作时，需要拷⻉对应数据，执⾏写操作

![](1.Redis%E7%AC%94%E8%AE%B0.assets/a14ed294feb623d5133d70791bbad8c8.jpeg)

**RDB问题**

1、执⾏间隔时间⻓，两次RDB之前可能存在数据丢失⻛险

2、fork⼦进程、压缩、写出RDB⽂件都⽐较耗时

#### **AOF**

Redis提供的⼀种持久化策略，也被称为追加模式或⽇志模式。与Redis的另⼀种持久化策略RDB不同，AOF是通过保存Redis服务器所执⾏的写命令来记录数据库的状态。

简单理解：Redis处理的每⼀个写命令都会记录在AOF⽂件，可以看做时命令⽇志⽂件。

其实这种⽅式就是当Redis有要求不能丢失任何写的内容，可以采⽤AOF持久化⽅式。

由于在使⽤AOF持久化⽅式时，redis会将每⼀个收到的命令都通过write函数追加到

⽂件中（默认appendonly.aof）。当redis重启时会通过重新执⾏⽂件中保存的写命令在内存中重建整个数据库内容。

**AOF命令**

⾸先AOF默认是关闭的，需要修改redis.conf配置⽂件来开启

AOF命令记录频率可以通过redis.conf配置⽂件控制

由此可以看出always安全性最⾼性能最差，以此类推逐步提⾼性能减少安全性

从Redis 7.0.0开始，Redis使⽤多部分AOF机制（AOFRW）。即把原来的单个AOF⽂件拆分为基础⽂件（最多⼀个）和增量⽂件（可能不⽌⼀个）。基础⽂件表示重写 AOF 时存在的数据的初始（RDB 或 AOF 格式）快照。增量⽂件包含⾃上次创建基本 AOF ⽂件以来的增量更改。所有这些⽂件都放在单独的⽬录中，并由清单⽂件跟 踪，这是为了解决随着Redis处理的写命令增多，AOF⽂件也会变得越来越⼤，命令回放的时间也会增多的问题。

![](1.Redis%E7%AC%94%E8%AE%B0.assets/c275d8e89ae96215f5cc05b5dd7e688d.png)![](1.Redis%E7%AC%94%E8%AE%B0.assets/02767b31735064dd99b32a8818b66532.png)![](media/02767b31735064dd99b32a8818b66532.png)BASE：表示基础的AOF，它⼀般由⼦进程通过重写产⽣，最多只有⼀个 INCR：表示增量AOF，它⼀般会在AOFRW开始创建，可能存在多个 HISTORY：表示历史的AOF，它由BASE和INCR AOF变化⽽来，每次AOFRW成功完成时，本次AOFRW之前对应的BASE和INCR都变成HISTORY，此类型AOF会被 Redis⾃动删除

###### 演示

1.  ⾸先注释掉之前的RDB，需要注释掉之前的策略，并且编写save ""表示禁⽤ RDB
2.  找到AOF配置
3.  可以设置保存AOF⽂件的⽬录名称，⽂件会保存在RDB你设置的⽬录中下的

    appenddirname⽬录中

![](1.Redis%E7%AC%94%E8%AE%B0.assets/68c0ecde368732a9fb31a5677fc07915.jpeg)![](1.Redis%E7%AC%94%E8%AE%B0.assets/51df08b76f7323f20149f5b85c51d4d7.jpeg)

**AOF rewrite（AOFRW）机制**

AOFRW会移除AOF中冗余的写命令，以等效的⽅式重写、⽣成⼀个新的AOF⽂件，来达到减少AOF⽂件⼤⼩的⽬的

机制触发有两种⽅式

1、⾃动

此时为两种条件同时满⾜，才会触发机制

![](1.Redis%E7%AC%94%E8%AE%B0.assets/e57e8937c7faf7a46c8bcf5f7292e83c.jpeg)条件1：根据上次重写后的AOF⽂件⼤⼩，判断当前AOF⽂件⼤⼩是否增⻓了1倍条件2：重新时需要满⾜设定的⽂件⼤⼩默认 64mb

2、⼿动

执⾏命令：bgrewriteaof命令

3、原理：

1：触发重写机制以后，Redis会创建⼀个⼦进程，此进程会读取现有的AOF⽂件，将包含的指令压缩并写⼊到临时⽂件中

2：此时主进程如果收到新的写指令，会把这些新指令累计到缓存区中，同时也会写⼊到原有的AOF⽂件中，保证重写过程失败，原有⽂件依旧可⽤

3：当⼦进程重写完成后，主进程会把重写期间产⽣的变化写⼊到新的ADF⽂件中

4：追加结束之后，新的ADF会覆盖⽼的ADF

![](1.Redis%E7%AC%94%E8%AE%B0.assets/0872e241ed4190c71d3d17212ce58733.jpeg)

**RDB与AOF混合持久化**

**RDB + AOF**：您还可以在同⼀个实例中组合 AOF 和 RDB。

以上是官⽹给出的建议，要注意的是，如果AOF被开启，那么Redis会优先加载AOF

⽂件

###### 具体如何应⽤

官⽅给出的解释如下：

⼀般情况下，如果您想要关系型数据库提供的数据安全程度相当的数据安全性，则应该使⽤这两种持久性⽅法。

如果您⾮常关⼼数据，但仍然可以忍受灾难发⽣时⼏分钟的数据丢失，那么您可以简单地单独使⽤ RDB。

有许多⽤户单独使⽤ AOF，但我们不⿎励这样做，因为时不时地拥有 RDB 快照对于进⾏数据库备份、更快地重新启动以及在 AOF 引擎出现错误时是⼀个好主意。

\*\*注意：\*\*同时开启RDB和AOF持久化时，重启时只会加载AOF⽂件，不会加载RDB⽂件，除⾮开始判断发现AOF⽂件不存在，会找RDB⽂件

###### 开启⽅式

设置redis.conf配置⽂件中的

###### 总结：

1.  RDB⽤做全量持久化
2.  AOF做增量持久化
3.  使⽤RDB进⾏快照存储，使⽤AOF持久化记录所有写操作，当重写策略满⾜或

    ⼿动触发时，将最新的数据储存为RDB

**Redis订阅发布**

![](media/28cbb716b0d5a7de3874ecc8c34bc5fb.png)Redis的发布/订阅（Pub/Sub）是⼀种消息通信模式：发送者（pub，即publisher）发送消息

![](media/28cbb716b0d5a7de3874ecc8c34bc5fb.png)订阅者（sub，即subscriber）接收消息。

Redis客户端可以订阅任何数量的频道（channel）。当有新消息发布到某个频道时，这个消息就会被发送到订阅它的客户端。

其实这个所谓的发布订阅，⼤家⼏乎天天都能⻅到，⽐如说我现在在这个账号中发布了视频，你们为什么能够看到，是因为你们关注了我，所以各位想看最新的课程内容，请记得关注，这样你们就可以收到课程更新的提醒了。其实这就是⼀种发布订阅机制的体现

![](1.Redis%E7%AC%94%E8%AE%B0.assets/56ad79d5f5c676654cfcca2a47910a50.png)

### 常⻅命令

![](1.Redis%E7%AC%94%E8%AE%B0.assets/33737569cc25bb2509d626cfc512c246.png)![](media/33737569cc25bb2509d626cfc512c246.png)SUBSCRIBE channel [channel ...]：订阅给定的⼀个或多个频道的信息。 PUBLISH channel message：将信息发送到指定的频道。

![](media/33737569cc25bb2509d626cfc512c246.png)UNSUBSCRIBE [channel [channel ...]]：指退订给定的频道。如果没有指定频道，则退订所有频道。

![](media/33737569cc25bb2509d626cfc512c246.png)PSUBSCRIBE pattern [pattern ...]：使⽤模式匹配订阅频道。

![](media/33737569cc25bb2509d626cfc512c246.png)PUNSUBSCRIBE [pattern [pattern ...]]：这个命令⽤于退订所有给定模式的频道。如果没有参数，那么客户端使⽤ PUNSUBSCRIBE 退订所有模式。

**订阅端**

| 3 | 1) | "subscribe"             |
|---|----|-------------------------|
| 4 | 2) | "qf"                    |
| 5 | 3) | (integer) 1             |
| 6 | 1) | "message"\# 收到消息    |
| 7 | 2) | "qf" \# 频道            |
| 8 | 3) | "redis" \# 具体消息内容 |

**发布端**

### 使⽤场景

1、实时消息系统

2、实时聊天

3、订阅、关注功能

**Redis主从复制介绍**

Redis主从复制是Redis内置的⼀种数据冗余和备份⽅式，同时也是分发读查询负载的⼀种⽅法。通过主从复制，可以有多个从服务器（Slave）复制⼀个主服务器

（Master）的数据。在这个系统中，数据的复制是单向的，只能由主服务器

（Master）到从服务器（Slave）。

重点：主节点可读写从节点：只能读

主从复制，读写分离！⼏乎百分之80情况下都是读的操作，所以多从节点才能减缓服务器压⼒。

### 为什么要有主从复制

⼏乎所有运⽤了Redis的软件中，都不可能只⽤⼀台Redis：

1、结构上，单个Redis服务器可能会出现单点故障，并且⼀台服务器处理所有请求，负载压⼒较⼤

2、容量上，单个Redis服务器内存容量有限，就算服务器内存很⼤也不可能全部⽤于Redis，⼀般来说单台Redis服务器内存最⼤不超过20G

### 主从复制的主要作⽤

1、数据冗余：主从复制实现了数据的热备份，是持久化的⼀种数据冗余⽅式

2、故障恢复：主节点⼀旦出现问题，可以由从节点提供服务，避免出现程序不可

⽤的情况，实现快速故障恢复。

3、负载均衡：在主从复制的基础之上，配合读写分离，主节点提供写服务，由从节点提供读服务，分担服务器负载，尤其是在读多写少场景下，可以⼤⼤提⾼Redis并发量

4、⾼可⽤（集群）基⽯：主从复制是集群和哨兵模式的基础。

# 主从复制搭建

![](media/e9b4585e84cdb79cf900aa9ebdb60ab7.png)主从复制最基本的也需要1主2从

![](1.Redis%E7%AC%94%E8%AE%B0.assets/6d9c63ec3f248b361b90a01a1fbb5a5e.png)默认情况下，每台Redis服务器都是主节点

![](media/e9b4585e84cdb79cf900aa9ebdb60ab7.png)⼀个主节点可以有多个从节点，但是⼀个从节点只能有⼀个主节点

### 环境搭建

只需要配置从库，因为每个Redis都是主库

⾸先我们需要⾄少3台服务器，我们⼿⾥⼀般之后⼀台Redis，所以我们需要通过修改配置⽂件的⽅式来模拟3台机器，修改配置⽂件，将端⼝信息改变，同时配置⽂件也需要三份：

每个配置⽂件要修改的配置

修改之后开启3台Redis

注意：通过系统服务关闭原有Redis，然后我们通过配置⽂件来⼿动启动3个Redis

![](1.Redis%E7%AC%94%E8%AE%B0.assets/54b0e148ca679e7a5a8320f023f5210f.jpeg)

### 主从复制具体搭建

###### ⼀主⼆从

1、配置6379为主机，先来登录⼀下

| 1 | redis-cli | -p | 6379 | -a | 753159 |
|---|-----------|----|------|----|--------|
| 2 | redis-cli | -p | 6380 | -a | 753159 |
| 3 | redis-cli | -p | 6381 | -a | 753159 |

2、配置命令（只需要配置从机）

主机状态

1.  127.0.0.1:6379\> info replication \# 查看状态
    1.  \# Replication
    2.  role:master \# 主机
    3.  connected_slaves:2 \# 从机数量2
    4.  slave0:ip=127.0.0.1,port=6380,state=online,offset=658,lag=1 \# 从机信息
    5.  slave1:ip=127.0.0.1,port=6381,state=online,offset=658,lag=1 \# 从机信息
    6.  master_failover_state:no-failover
    7.  master_replid:a35f6c06dd068dc671e113b4a940531ce1ea88d2
    8.  master_replid2:0000000000000000000000000000000000000000
    9.  master_repl_offset:658
    10. second_repl_offset:-1
    11. repl_backlog_active:1
    12. repl_backlog_size:1048576
    13. repl_backlog_first_byte_offset:1
    14. repl_backlog_histlen:658

从机状态

⽬前我们是通过命令来配置的，是暂时的，⼀旦服务停机，就会失效，如果我们想要永久有效，需要来改配置！

![](1.Redis%E7%AC%94%E8%AE%B0.assets/439ba8522b06821f0e83ed5df5b05e47.png)

###### 注意：

1、主机可以写，从机不可以

2、主机如果宕机，重新连接以后，依旧可以成功连接

###### 原理总结

1、Slave启动成功连接到Master后会发送⼀个sync（同步）命令

2、Master收到命令以后，会启动后台存盘进程，同时收集所有修改命令

3、后台存盘线程执⾏完毕之后，会将Master整体数据**全量复制**到slave中，完成第

⼀次同步

全量复制：将Master中所有数据进⾏保存传输到Slave中

增量复制：Master后续新增的修改命令会以此传给Slave，完成同步注意：如果有Slave断开，⼀旦重新连接就会触发全量复制

### 主从模型

其实主从模式有很多种，如图为2中

![](1.Redis%E7%AC%94%E8%AE%B0.assets/15cfecbaa884088b5b4605c0659e82b5.png)

![](1.Redis%E7%AC%94%E8%AE%B0.assets/3d554b164e667e1ee0abfc088d8c6471.png)

第⼆种配置⽅式⾮常简单，只要把6381主机改为6380即可

注意：这种⽅式虽然6380也成为了主机，依旧不能执⾏写操作，但同步依旧好⽤

6380状态，不可以执⾏写操作，本质上还是从机

6379

当前这个案例中⼤家想⼀个问题，如果我们的Master现在只有⼀台服务器，并且如果这⼀台服务器宕机了不能及时恢复，造成服务不可⽤，势必会造成很⼤的影响，所以实际⽣产中，我们会⽤到主从模式的进阶，哨兵模式来解决这个问题

# 哨兵模式详解

### 相关概念

Redis的哨兵模式（Sentinel mode）是⼀个⾼可⽤解决⽅案，当运⾏多个Redis实例并且需要⾃动故障转移时，哨兵模式⾮常有⽤。

哨兵模式主要有三个⽬标：

1.  监控：哨兵模式会不断地检查主服务器和从服务器是否按预期⼯作。
2.  通知：如果某些Redis实例有故障，哨兵模式可以通过API向管理员或者其他应

    ⽤程序发送通知。

3.  ⾃动故障转移：如果主服务器⽆法正常⼯作，哨兵模式可以开始⼀个故障转移过程，由⼀个从服务器升级为新的主服务器，并让其他从服务器改变他们的主服务器为新的主服务器。

    在⼀个典型的哨兵模式下，⾄少需要3个哨兵实例来避免“脑裂”（⽹络分裂导致多个主服务器同时存在）。哨兵们会通过投票来决定主服务器是否已经下线，以及选择哪个从服务器升级为新的主服务器。

    哨兵模式的实现是基于发布-订阅模式的，每个哨兵节点都会订阅其它哨兵节点的信息，这样当主服务器出现故障时，哨兵节点可以及时进⾏⼴播，实现快速故障转 移。

    具体来说，Redis的哨兵模式有以下⼏个主要特点：

    ![](1.Redis%E7%AC%94%E8%AE%B0.assets/8532f416b8db587018c9efa42147355d.png)哨兵模式⾃动转移失败的主服务器到⼀个从服务器。

    ![](1.Redis%E7%AC%94%E8%AE%B0.assets/8532f416b8db587018c9efa42147355d.png)哨兵模式持续监控所有Redis服务器，以便在需要时报告错误。

    ![](1.Redis%E7%AC%94%E8%AE%B0.assets/8532f416b8db587018c9efa42147355d.png)通过提供⼀个基于哨兵的API，客户端可以⾃动发现新的主服务器地址。

Sentinel（哨兵）时基于⼼跳机制检测服务状态的，每隔1秒向每隔实例发送⼀个 ping命令，如果某个sentinel发现某Redis实例未在规定时间内响应，则认为该实例**主观下线**，若超过指定数量（quorum）的sentinel都认为该实例**主观下线**，则该实例**客观下线**。quorum的值最好超过Sentinel实例数的⼀半

在实际应⽤中，哨兵模式通常⽤于提⾼Redis的可⽤性，对于有⾼可⽤需求的系统，哨兵模式是⼀个很好的解决⽅案。

\*\*重点：\*\*实现⾃动转移失败的主服务器到另外⼀个服务器上

![](1.Redis%E7%AC%94%E8%AE%B0.assets/64e93e2d778a3c41e5a16045e3895fa9.jpeg)

1、如果此时主服务器宕机，哨兵1检测到了，系统并不会⽴即进⾏failover（故障转移）过程

2、此时仅仅是哨兵1主管的认为主服务不可⽤，此现象为**主观下线**

3、当后续的哨兵也检测到主服务器不可⽤时，并且数量达指定数量时

4、哨兵之间就会进⾏⼀次投票，投票结果由1个哨兵发起，进⾏failover操作

5、切换成功之后，就会通过发布订阅模式，让各个哨兵把⾃⼰监控的从服务器切换主机，这个过程为**客观下线**

###### 选举过程

⼀旦发现master故障，sentinel需要在salve中选择⼀个作为新的master，选择依据是这样的:

1、⾸先会判断slave节点与master节点断开时间⻓短，如果超过指定值 (down-after- milliseconds\*10)则会排除该slave节点

2、然后判断slave节点的slave-priority值，越⼩优先级越⾼，如果是0则永不参与选举

3、 如果slave-prority⼀样，则判断slave节点的offset值，越⼤说明数据越新，优先级越⾼

4、最后是判断slave节点的运⾏id⼤⼩，越⼩优先级越⾼

###### 故障转移

1、Sentinel给备选的节点发送slaveof on one命令，让该节点成为Maskter

2、Sentinel给其他slave发送 “slaveof ip 端⼝” 命令，开始从Master上同步数据

3、最后Sentinel将故障节点标记为slave（执⾏slaveof ip 端⼝命令），故障节点恢复以后也会成为新Master的slave

### 简单演示

演示之前，我们需要先看⼀下官⽅提供的sentinel.conf⽂件⾥的配置，我们可以通过⼯具来直接查看，⼤家会惊奇的发现，很多我们都认识

![](1.Redis%E7%AC%94%E8%AE%B0.assets/6e93b1d48e93facaaad030cb1d21e97d.jpeg)

其中⽐较关键的，和⼤家不熟悉的我给⼤家列出来了

1.  \# master-name⾃定义
    1.  \# ip 主Redis ip
    2.  \# quorum 表示最少有⼏个哨兵认可进⾏故障迁移

        6

        7 \# 主服务器进⼊密码

        8 \# sentinel auth-pass \<master-name\> \<password\>

        9 sentinel auth-pass mymaster 753159

        10

        11 \# =====================其他命令==========================

        12

        13 sentinel down-after-milliseconds \<master-name\> \<milliseconds\> \#指定多少毫秒之后，主节点没有应答哨兵，此时哨兵主观上认为主节点下线

        14

        15 sentinel parallel-syncs \<master-name\> \<nums\> \#表示允许并⾏同步的slave个数，当Master挂了后，哨兵会选出新的Master，此时，剩余的slave会向新的master发起同步数据

        16

        17 sentinel failover-timeout \<master-name\> \<milliseconds\> \#故障转移的超时时间，进⾏故障转移时，如果超过设置的毫秒，表示故障转移失败

        18

        19 sentinel notification-script \<master-name\> \<script-path\> \#配置当某⼀事件发⽣时所需要执⾏的脚本

        20

        21 sentinel client-reconfig-script \<master-name\> \<script-path\> \#客户端重新配置主节点参数脚本

###### 案例演示

⾸先让我们的集群变为⼀主⼆从，然后配置哨兵配置⽂件，这⾥最好建⽴⼀个

mysentinel⽬录，把配置放⼊到其中，依旧是建⽴3个⽂件，分别修改端⼝

**注意：redis79.conf也需要加上 masterauth 753159**

在/root/opt/redis-7.0.11此⽬录下建⽴⼀个mysentinel⽬录，然后直接编写三个⽂件

sentinel26379.conf：26379

sentinel26380.conf：26380 sentinel26381.conf：26381

启动哨兵，这⾥注意要通过sentinel配置来启动

配置成功之后，让主节点6379下线，通过命令查看另外两个节点那个变成了主节点，我这⾥是6381

即便6379再次上线，也只会变成从节点了

**Redis缓存穿透和雪崩**

Redis缓存的应⽤，极⼤提升了应⽤程序的性能和效率，特别是数据查询⽅⾯。但同时，它也有⼀些列的问题，数据⼀致性就是其中⽐较重点的问题。那么这个问题其实⽬前的解决⽅案都是最终⼀致性，当然也是要看具体需求⽽定。

这其中还有⼀些缓存穿透、雪崩也是⽐较经典的问题

### 缓存穿透

缓存穿透是指查询⼀个在缓存和数据库中都不存在的数据。由于缓存没有这个数据，所以每次查询都会“穿透”缓存直接查询数据库，如果有⼤量此类查询，会给数据库带来极⼤的压⼒。

这种情况如果⼀旦访问量过⼤，很容易造成MySQL服务器宕机

![](1.Redis%E7%AC%94%E8%AE%B0.assets/1c723fa65fc9b585b467fb7c1dc4c8ec.jpeg)

###### 解决办法

1.  **布隆过滤器（Bloom Filter）**：这是⼀种空间效率极⾼的概率型数据结构，它可以⽤来判断⼀个元素是否在⼀个集合中。将所有可能会被请求的数据的key先存⼊布隆过滤器，当有请求过来时，先使⽤布隆过滤器判断数据是否存在，如果布隆过滤器判断数据不存在，那就直接返回，不再查询数据库。
2.  **空值缓存**：即使⼀个key在数据库中没有对应的值，也依然将这个结果进⾏缓存，但是可以设置⼀个较短的过期时间。这样，即使攻击者使⽤⼤量不存在的 key进⾏攻击，也只能触及到缓存层，⽆法达到数据库层。
3.  **限流**：对单个⽤户的访问频率进⾏限制，防⽌恶意⽤户或者爬⾍通过⾼并发的

    ⽅式进⾏攻击。

### 缓存击穿（缓存过期的瞬间）

缓存击穿是指⼀个存在的key在缓存中过期，此时有⼤量的并发请求这个key，都查不到结果，于是都去数据库中查询并回填缓存，造成数据库短时间内压⼒过⼤。简单来说，缓存击穿是指请求的数据在缓存中不存在（可能是过期，或者根本没有缓存过），导致所有的请求都去请求数据库，可能会导致数据库瞬间压⼒过⼤。

为了防⽌缓存击穿，有⼀些常⻅的解决办法：

1.  **设置热点数据永不过期**：如果某些数据特别热⻔，访问的频率远远超过其他数据，那么可以将这部分数据设置为永不过期，这样就可以避免⼤量请求突然落到数据库上。
2.  **加锁排队**：对于查询数据库的操作进⾏加锁，即在缓存失效的时候，不是直接去查询数据库，⽽是先进⾏加锁操作。第⼀个请求获取到锁，然后进⾏数据库查询并回填缓存，后续的请求如果获取不到锁，可以选择等待或者返回未获取到数据。
3.  **使⽤互斥锁**：可以在缓存失效的时候使⽤互斥锁，即第⼀个请求去数据库查找数据，其他的请求就等待，当第⼀个请求处理完毕后，其他请求再从缓存中获取数据。

    这些⽅法可以根据实际的业务情况进⾏选择，理想的情况是可以将数据库的访问量降到最低，从⽽避免数据库因为过⼤的压⼒⽽崩溃。

### 缓存雪崩

缓存雪崩是指在缓存系统中，由于⼤量的数据同时失效，⽽引发⼤量的请求同时去请求数据库，从⽽可能会导致数据库的压⼒过⼤甚⾄导致数据库崩溃的情况。⽐ 如，如果⼀个系统的缓存策略设置的是某⼀刻所有的缓存同时失效，那么在这⼀ 刻，所有的请求都将会去请求数据库，这就可能会造成缓存雪崩。

其实最致命的雪崩就是服务器某个节点突然宕机或者断⽹，因为此时对数据库服务器的压⼒是不可预估的，很有可能瞬间把数据库压垮！

为了防⽌缓存雪崩，有⼀些常⻅的解决策略：

1.  **缓存数据的过期时间设置为随机**：避免所有数据同时过期，不会出现瞬间⼤量的数据库请求。
2.  **使⽤多级缓存策略**：例如，使⽤⼀级缓存和⼆级缓存，⼀级缓存的失效时间短于⼆级缓存，⼀级缓存失效后，请求会访问⼆级缓存，⽽不是直接落到数据 库。
3.  **缓存预热**：在业务低峰期，对将要过期的缓存进⾏预热，预热的⽅式就是提前去更新数据。
4.  **使⽤⾼可⽤的缓存集群**：即使某些节点挂掉，仍然可以保证系统的可⽤性。

    这些策略可以根据实际情况进⾏选择和使⽤，以提⾼系统的稳定性和可⽤性，减少因为⼤量请求落到数据库⽽引发的问题。

    千锋精品教程-好学得不像实⼒派！关注公众号【Java架构栈】下载所有课程代码课件及⼯具
