# [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

## 一、问题



给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

 

**示例 1：**

![img](5.59 螺旋矩阵 II.assets/spiraln.jpg)

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

**示例 2：**

```
输入：n = 1
输出：[[1]]
```

 

**提示：**

- `1 <= n <= 20`

## 二、思路

### 2.1 方法一

```java
class Solution {
    /**
     * 生成指定大小的螺旋矩阵。
     *
     * @param n 矩阵的边长（正整数）
     * @return 一个 n x n 的螺旋矩阵，其中元素按螺旋顺序填充
     */
    public int[][] generateMatrix(int n) {
        // 定义最大数字，即矩阵所有元素之和
        int maxNum = n * n;
        
        // 初始化当前填充的数字为 1
        int curNum = 1;

        // 创建一个 n x n 的矩阵用于存放生成的结果
        int[][] matrix = new int[n][n];

        // 初始化当前位置的行、列坐标为 (0, 0)
        int row = 0, column = 0;

        // 定义四个移动方向：右、下、左、上，分别对应 (0, 1)，(1, 0)，(0, -1)，(-1, 0)
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        // 初始化当前移动方向的索引为 0，即向右移动
        int directionIndex = 0;

        // 当还有数字需要填充时（即 curNum 小于等于最大数字）
        while (curNum <= maxNum) {
            // 在当前位置填入当前数字
            matrix[row][column] = curNum;
            curNum++;

            // 根据当前方向计算下一个位置的行和列
            int nextRow = row + directions[directionIndex][0];
            int nextColumn = column + directions[directionIndex][1];

            // 判断下一个位置是否超出矩阵边界或已被填充过
            // 若满足条件，则顺时针旋转至下一个方向（方向索引加 1 并取模 4）
            if (nextRow < 0 || nextRow >= n || nextColumn < 0 || nextColumn >= n || matrix[nextRow][nextColumn] != 0) {
                directionIndex = (directionIndex + 1) % 4;
            }

            // 更新当前位置的行和列为下一个位置
            row = row + directions[directionIndex][0];
            column = column + directions[directionIndex][1];
        }

        // 返回生成的螺旋矩阵
        return matrix;
    }
}
```

注释已详细解释了各部分功能和逻辑：

1. **类与方法定义**：定义一个名为 `Solution` 的类，其中包含一个方法 `generateMatrix`，接收一个整数 `n`（矩阵的边长）作为参数，返回值类型为 `int[][]`，表示生成的螺旋矩阵。

2. **变量声明**：
   - `maxNum`：存储矩阵的最大数字，即 `n * n`，用于判断是否还有数字需要填充。
   - `curNum`：当前填充的数字，初始值为 `1`。
   - `matrix`：用于存储生成的螺旋矩阵，是一个 `n x n` 的整数数组。
   - `row` 和 `column`：当前填充位置的行和列坐标，初始值均为 `0`。
   - `directions`：存储四个移动方向，分别是右、下、左、上，每个方向用一个包含两个整数的数组表示行和列的增量。
   - `directionIndex`：当前移动方向的索引，初始值为 `0`，表示向右移动。

3. **生成螺旋矩阵**：
   - 使用 `while` 循环，当 `curNum` 小于等于 `maxNum` 时继续填充矩阵。
   - 在当前位置 (`row`, `column`) 填入当前数字 `curNum`，并递增 `curNum`。
   - 根据当前方向索引 `directionIndex` 计算下一个填充位置的行 `nextRow` 和列 `nextColumn`。
   - 判断下一个位置是否超出矩阵边界或已被填充，如满足条件则顺时针旋转至下一个方向（更新 `directionIndex`）。
   - 更新当前位置的行和列为下一个位置的行和列。

4. **返回结果**：当循环结束，所有数字已正确填充到矩阵中，返回生成的螺旋矩阵 `matrix`。

### 2.2 方法二

```java
class Solution {
    /**
     * 生成指定大小的螺旋矩阵。
     *
     * @param n 矩阵的边长（正整数）
     * @return 一个 n x n 的螺旋矩阵，其中元素按螺旋顺序填充
     */
    public int[][] generateMatrix(int n) {
        // 初始化当前填充的数字为 1
        int num = 1;

        // 创建一个 n x n 的矩阵用于存放生成的结果
        int[][] matrix = new int[n][n];

        // 初始化当前行的左右边界以及当前列的上下边界
        int left = 0, right = n - 1;
        int top = 0, bottom = n - 1;

        // 当边界未交叉（即还有数字需要填充）时，执行循环
        while (left <= right && top <= bottom) {

            // 填充当前行（从左到右）
            for (int column = left; column <= right; column++) {
                matrix[top][column] = num;
                num++;
            }

            // 填充当前列（从上到下）
            for (int row = top + 1; row <= bottom; row++) {
                matrix[row][right] = num;
                num++;
            }

            // 如果还有内部的环需要填充（即当前边界内不止一个元素）
            if (left < right && top < bottom) {

                // 填充底部行（从右到左）
                for (int column = right - 1; column > left; column--) {
                    matrix[bottom][column] = num;
                    num++;
                }

                // 填充左侧列（从下到上）
                for (int row = bottom; row > top; row--) {
                    matrix[row][left] = num;
                    num++;
                }
            }

            // 缩小当前行的左右边界以及当前列的上下边界，准备填充下一环
            left++;
            right--;
            top++;
            bottom--;
        }

        // 返回生成的螺旋矩阵
        return matrix;
    }
}
```

注释已详细解释了各部分功能和逻辑：

1. **类与方法定义**：定义一个名为 `Solution` 的类，其中包含一个方法 `generateMatrix`，接收一个整数 `n`（矩阵的边长）作为参数，返回值类型为 `int[][]`，表示生成的螺旋矩阵。

2. **变量声明**：
   - `num`：当前填充的数字，初始值为 `1`。
   - `matrix`：用于存储生成的螺旋矩阵，是一个 `n x n` 的整数数组。
   - `left` 和 `right`：当前行的左右边界，初始值分别为 `0` 和 `n - 1`。
   - `top` 和 `bottom`：当前列的上下边界，初始值分别为 `0` 和 `n - 1`。

3. **生成螺旋矩阵**：
   - 使用 `while` 循环，当当前行的左右边界和当前列的上下边界未交叉时（即还有数字需要填充），执行循环体。
   - **填充当前行**：使用 `for` 循环，从左到右依次将数字 `num` 填充到当前行，同时递增 `num`。
   - **填充当前列**：使用 `for` 循环，从上到下依次将数字 `num` 填充到当前列，同时递增 `num`。
   - **检查并填充内部环**：若当前边界内不止一个元素（即 `left < right` 且 `top < bottom`），分别填充底部行（从右到左）和左侧列（从下到上），同时递增 `num`。
   - **更新边界**：缩小当前行的左右边界和当前列的上下边界，为填充下一环做准备。

4. **返回结果**：当循环结束，所有数字已正确填充到矩阵中，返回生成的螺旋矩阵 `matrix`。

## 三、类似题目

- [54.螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)
- [剑指Offer 29.顺时针打印矩阵](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

