# [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

## 一、问题



给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

 

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

 

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。
```

**示例 3:**

```
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```

 

**提示：**

- `m == s.length`
- `n == t.length`
- `1 <= m, n <= 105`
- `s` 和 `t` 由英文字母组成

 

**进阶：**你能设计一个在 `o(m+n)` 时间内解决此问题的算法吗？

## 二、思路

### 2.1 滑动窗口

```java
class Solution {
    /**
     * 寻找给定字符串 s 中包含目标字符串 t 所有字符的最短子串。
     *
     * @param s 原字符串，非空
     * @param t 目标字符串，非空
     * @return 最短子串，若不存在符合条件的子串则返回空字符串
     */
    public String minWindow(String s, String t) {
        // 记录 t 中每个字符的出现次数
        Map<Character, Integer> tMap = new HashMap<>();
        for (char c : t.toCharArray()) {
            tMap.put(c, tMap.getOrDefault(c, 0) + 1);
        }

        int left = 0; // 窗口左边界
        int right = 0; // 窗口右边界
        int minLen = Integer.MAX_VALUE; // 最小子串长度
        int start = 0; // 最小子串的起始位置
        int count = t.length(); // 匹配字符的计数

        // 移动右边界，扩展窗口
        while (right < s.length()) {
            char c = s.charAt(right);
            if (tMap.containsKey(c)) {
                if (tMap.get(c) > 0) {
                    count--; // 若该字符在 t 中还有待匹配的实例，则减少计数
                }
                tMap.put(c, tMap.getOrDefault(c, 0) - 1); // 更新字符出现次数
            }
            right++; // 移动右边界

            // 当窗口包含所有 t 中的字符时，开始收缩窗口
            while (count == 0) {
                if (right - left < minLen) { // 更新最小子串长度及起始位置
                    minLen = right - left;
                    start = left;
                }
                char leftChar = s.charAt(left);
                if (tMap.containsKey(leftChar)) {
                    tMap.put(leftChar, tMap.get(leftChar) + 1); // 还原字符出现次数
                    if (tMap.get(leftChar) > 0) {
                        count++; // 若还原后该字符在 t 中仍有待匹配的实例，则增加计数
                    }
                }
                left++; // 移动左边界，收缩窗口
            }
        }

        // 若未找到符合条件的子串，返回空字符串
        if (minLen == Integer.MAX_VALUE) {
            return "";
        }
        // 否则，返回找到的最短子串
        return s.substring(start, start + minLen);
    }
}
```

这段代码定义了一个名为 `Solution` 的类，其中包含一个方法 `minWindow`，用于寻找给定字符串 `s` 中包含目标字符串 `t` 所有字符的最短子串。注释已详细解释了各部分功能和逻辑：

1. **类与方法定义**：定义一个名为 `Solution` 的类，其中包含一个方法 `minWindow`，接收两个字符串参数 `s`（原字符串）和 `t`（目标字符串），返回值类型为 `String`，表示找到的最短子串。

2. **初始化变量**：
   - `tMap`：使用 `HashMap` 存储目标字符串 `t` 中每个字符及其出现次数。
   - `left` 和 `right`：分别表示当前窗口的左、右边界，初始值均为 `0`。
   - `minLen`：记录已找到的最短子串长度，初始值为 `Integer.MAX_VALUE`。
   - `start`：记录最短子串的起始位置，初始值为 `0`。
   - `count`：记录还需匹配的字符数量，初始化为 `t` 的长度。

3. **构建 tMap**：
   - 遍历 `t` 的字符，计算每个字符在 `t` 中的出现次数，并存入 `tMap`。

4. **滑动窗口遍历**：
   - 使用一个 `while` 循环，以右边界 `right` 为主导，不断向右扩展窗口。
   - 对于窗口内的每个字符：
     - 检查其是否存在于 `tMap` 中：
       - 若存在，且该字符在 `t` 中还有待匹配的实例，则减少 `count`。
       - 更新该字符在 `tMap` 中的出现次数。
     - 移动右边界 `right` 向右一位。
   - 当窗口内包含所有 `t` 中的字符（即 `count == 0`）时，开始收缩窗口：
     - 更新最小子串长度 `minLen` 及起始位置 `start`。
     - 还原窗口左边界字符在 `tMap` 中的出现次数，并根据还原后的状态调整 `count`。
     - 移动左边界 `left` 向右一位，继续收缩窗口。

5. **返回结果**：
   - 若未找到符合条件的子串（即 `minLen` 仍为 `Integer.MAX_VALUE`），返回空字符串。
   - 否则，使用 `substring` 方法从原字符串 `s` 中提取出找到的最短子串，并返回。

### 2.2 方法二

```java
class Solution {
    /**
     * 寻找给定字符串 s 中包含目标字符串 t 所有字符的最短子串。
     *
     * @param s 原字符串，非空
     * @param t 目标字符串，非空
     * @return 最短子串，若不存在符合条件的子串则返回空字符串
     */
    public String minWindow(String s, String t) {
        // 检查输入字符串是否为空，为空则返回空字符串
        if (s == null || t == null) {
            return "";
        }

        // 初始化一个大小为 128 的整型数组 need，用于记录目标字符串 t 中各字符的需求量（即需匹配的次数）
        int[] need = new int[128];
        for (int i = 0; i < t.length(); i++) {
            need[t.charAt(i)]++; // 对目标字符串 t 中的每个字符，增加其需求量
        }

        // 初始化滑动窗口相关变量
        int l = 0, r = 0; // 左、右窗口边界
        int start = 0; // 最小子串起始位置
        int count = t.length(); // 剩余需匹配的字符数量
        int size = Integer.MAX_VALUE; // 最小子串长度

        // 使用滑动窗口遍历原字符串 s
        while (r < s.length()) {
            char c = s.charAt(r); // 取当前窗口右侧字符

            // 如果该字符在目标字符串 t 中有需求量
            if (need[c] > 0) {
                count--; // 减少剩余需匹配的字符数量
            }

            // 更新字符需求量（实际需求量减去已匹配的数量）
            need[c]--;

            // 当剩余需匹配的字符数量为 0，说明当前窗口包含目标字符串 t 的所有字符
            if (count == 0) {
                // 移除窗口左侧可能已超过需求量的字符
                while (l < r && need[s.charAt(l)] < 0) {
                    need[s.charAt(l)]++; // 增加字符需求量（还原）
                    l++; // 左移窗口边界
                }

                // 更新最小子串长度和起始位置（如果当前窗口长度更短）
                if (r - l + 1 < size) {
                    size = r - l + 1;
                    start = l;
                }

                // 将窗口左侧字符移出窗口，并增加其需求量（还原）
                need[s.charAt(l)]++;
                l++;

                // 增加剩余需匹配的字符数量，准备移动窗口右侧边界
                count++;
            }

            // 移动窗口右侧边界
            r++;
        }

        // 若未找到符合条件的子串，返回空字符串
        return size == Integer.MAX_VALUE ? "" : s.substring(start, start + size);
    }
}
```

这段代码定义了一个名为 `Solution` 的类，其中包含一个方法 `minWindow`，用于寻找给定字符串 `s` 中包含目标字符串 `t` 所有字符的最短子串。注释已详细解释了各部分功能和逻辑：

1. **类与方法定义**：定义一个名为 `Solution` 的类，其中包含一个方法 `minWindow`，接收两个字符串参数 `s`（原字符串）和 `t`（目标字符串），返回值类型为 `String`，表示找到的最短子串。

2. **输入检查**：检查输入字符串 `s` 和 `t` 是否为空，若为空则返回空字符串。

3. **初始化需求量数组**：
   - 使用一个大小为 128 的整型数组 `need`，记录目标字符串 `t` 中各字符的需求量（即需匹配的次数）。
   - 遍历 `t` 的字符，对每个字符在其对应的 `need` 数组索引处增加需求量。

4. **初始化滑动窗口相关变量**：
   - `l` 和 `r` 分别表示当前窗口的左、右边界，初始值均为 `0`。
   - `start` 记录最短子串的起始位置，初始值为 `0`。
   - `count` 记录还需匹配的字符数量，初始化为 `t` 的长度。
   - `size` 记录已找到的最短子串长度，初始值为 `Integer.MAX_VALUE`。

5. **滑动窗口遍历**：
   - 使用一个 `while` 循环，以右边界 `r` 为主导，不断向右扩展窗口。
   - 对于窗口内的每个字符：
     - 检查其是否在目标字符串 `t` 中有需求量，若有则减少 `count`。
     - 更新该字符在 `need` 数组中的需求量（实际需求量减去已匹配的数量）。
     - 当窗口内包含所有 `t` 中的字符（即 `count == 0`）时，执行以下操作：
       - 移除窗口左侧可能已超过需求量的字符。
       - 更新最小子串长度 `size` 及起始位置 `start`（如果当前窗口长度更短）。
       - 将窗口左侧字符移出窗口，并还原其需求量。
       - 增加 `count`，准备移动窗口右侧边界。
   - 移动右边界 `r` 向右一位。

6. **返回结果**：
   - 若未找到符合条件的子串（即 `size` 仍为 `Integer.MAX_VALUE`），返回空字符串。
   - 否则，使用 `substring` 方法从原字符串 `s` 中提取出找到的最短子串，并返回。

