# [面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

## 一、题目



给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[<img src="6.面试题 02.07. 链表相交.assets/160_statement.png" alt="img" style="zoom:80%;" />](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

 

**示例 1：**

[<img src="6.面试题 02.07. 链表相交.assets/160_example_1.png" alt="img" style="zoom:80%;" />](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

**示例 2：**

[<img src="6.面试题 02.07. 链表相交.assets/160_example_2.png" alt="img" style="zoom:80%;" />](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)

```
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

**示例 3：**

[<img src="6.面试题 02.07. 链表相交.assets/160_example_3.png" alt="img" style="zoom:80%;" />](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
```

 

**提示：**

- `listA` 中节点数目为 `m`
- `listB` 中节点数目为 `n`
- `0 <= m, n <= 3 * 104`
- `1 <= Node.val <= 105`
- `0 <= skipA <= m`
- `0 <= skipB <= n`
- 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`
- 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA + 1] == listB[skipB + 1]`

 

**进阶：**你能否设计一个时间复杂度 `O(n)` 、仅用 `O(1)` 内存的解决方案？

## 二、思路

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // 定义两个指针分别遍历链表A和B
        ListNode curA = headA;
        ListNode curB = headB;
        
        // 初始化记录链表A和B的长度
        int lenA = 0, lenB = 0;
        
        // 计算链表A的长度
        while (curA != null) {
            lenA++;
            curA = curA.next;
        }
        
        // 计算链表B的长度
        while (curB != null) {
            lenB++;
            curB = curB.next;
        }
        
        // 重置curA和curB回链表头节点
        curA = headA;
        curB = headB;
        
        // 确保curA指向较长链表的头节点，lenA记录较长链表的长度
        if (lenB > lenA) {
            // 交换lenA和lenB的值
            int tmpLen = lenA;
            lenA = lenB;
            lenB = tmpLen;
            
            // 交换curA和curB的指向
            ListNode tmpNode = curA;
            curA = curB;
            curB = tmpNode;
        }
        
        // 计算两链表长度差
        int gap = lenA - lenB;
        
        // 将长链表的指针curA先向前移动gap个节点，使两指针处于同一“起跑线”（即两链表末尾对齐）
        while (gap-- > 0) {
            curA = curA.next;
        }
        
        // 同步遍历curA和curB，当二者相遇时，说明找到了交点，直接返回该节点
        while (curA != null) {
            if (curA == curB) {
                return curA;
            }
            curA = curA.next;
            curB = curB.next;
        }
        
        // 如果遍历结束仍未找到交点，则两链表无交集，返回null
        return null;
    }
}
```

寻找两个链表 `headA` 和 `headB` 的交点。如果存在交点，返回该交点；否则返回 `null` 表示无交点。

注释已详细解释了各部分功能和逻辑：

1. **初始化指针与长度变量**：定义两个指针 `curA` 和 `curB` 分别指向链表 `headA` 和 `headB` 的头节点，以及两个整数变量 `lenA` 和 `lenB` 分别记录链表 `A` 和 `B` 的长度。

2. **计算链表长度**：使用两个 `while` 循环分别遍历链表 `A` 和 `B`，递增长度计数器并移动指针至各自的末尾。此时，`lenA` 和 `lenB` 分别存储了两个链表的长度。

3. **重置指针与调整长链表**：将 `curA` 和 `curB` 重新设置回各自链表的头节点。然后判断哪个链表更长，若 `lenB` 大于 `lenA`，则交换 `lenA` 和 `lenB` 的值，并同时交换 `curA` 和 `curB` 的指向，确保 `curA` 指向较长链表的头节点。

4. **计算长度差**：计算两链表长度之差 `gap`，即较长链表比较短链表多出的节点数。

5. **调整长链表指针**：将长链表的指针 `curA` 先向前移动 `gap` 个节点，使得两链表的指针处于同一“起跑线”，即它们在各自链表中的相对位置对应于两链表末尾对齐。

6. **同步遍历查找交点**：同时遍历调整后的 `curA` 和 `curB`，每当二者指向相同的节点时，说明找到了交点，直接返回该节点。若遍历结束后仍未找到交点，则两链表无交集，返回 `null`。